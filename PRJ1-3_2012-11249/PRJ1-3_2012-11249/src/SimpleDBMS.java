/* Generated By:JavaCC: Do not edit this line. SimpleDBMS.java */
import java.util.*;
import java.util.Set;
import java.util.HashSet;
import java.util.Arrays;
import java.util.Vector;
import java.util.StringTokenizer;
import java.io.File;
import java.io.UnsupportedEncodingException;


import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseEntry;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.DatabaseConfig;
import com.sleepycat.je.Cursor;

import com.sleepycat.je.Environment;
import com.sleepycat.je.EnvironmentConfig;

import com.sleepycat.je.LockMode;
import com.sleepycat.je.OperationStatus;




public class SimpleDBMS implements SimpleDBMSConstants {
  class TableExpression {
    ArrayList<String> tableReferenceList;
    BooleanValueExpression bve;

    public TableExpression(ArrayList<String> tableReferenceList, BooleanValueExpression bve) {
                this.tableReferenceList = tableReferenceList;
                this.bve = bve;
    }
  }
  class CompOperand {
        String compOperandAux;
        String columnName;
        String comparableValue;

        public CompOperand(String compOperandAux, String columnName, String comparableValue) {
                this.compOperandAux = compOperandAux;
                this.columnName = columnName;
                this.comparableValue = comparableValue;
        }
        public void print() {
                if(compOperandAux != null) { System.out.print(compOperandAux); }
                if(columnName != null) { System.out.print(columnName); }
                if(comparableValue != null) { System.out.print(comparableValue); }
        }
}


class ComparisonPredicate {
        CompOperand co1;
        CompOperand co2;
        String compOp;

        public ComparisonPredicate(CompOperand co1, CompOperand co2, String compOp) {
                this.co1 = co1;
                this.co2 = co2;
                this.compOp = compOp;
        }
        public void print() {
                co1.print();
                System.out.print(" " + compOp + " ");
                co2.print();
                System.out.println();
        }
}

class NullPredicate {
        String nullPredicateAux;
        String columnName;
        String nullOperation;

        public NullPredicate(String nullPredicateAux, String columnName, String nullOperation) {
                this.nullPredicateAux = nullPredicateAux;
                this.columnName = columnName;
                this.nullOperation = nullOperation;
        }
        public void print() {
                if(nullPredicateAux != null) { System.out.print(nullPredicateAux + " "); }
                if(columnName != null) { System.out.print(columnName + " "); }
                if(nullPredicateAux == null && columnName == null) { System.out.println("NullPredicate both null error"); }
                if(nullPredicateAux != null && columnName != null) { System.out.println("NullPredicate none null error"); }
                System.out.println(nullOperation);
        }
}

class Predicate {
        ComparisonPredicate cp;
        NullPredicate np;

        public Predicate(ComparisonPredicate cp, NullPredicate np) {
                this.cp = cp;
                this.np = np;
        }
        public void print() {
                if(cp != null) cp.print();
                if(np != null) np.print();
                if(cp == null && np == null) { System.out.println("Predicate both null error"); }
                if(cp != null && np != null) { System.out.println("Predicate none null error"); }
        }
}

class BooleanTest {
        Predicate p;
        BooleanValueExpression bve;

        public BooleanTest(Predicate p, BooleanValueExpression bve) {
                this.p = p;
                this.bve = bve;
        }
        public void print() {
                if(p != null) { p.print(); }
                if(bve != null) { bve.print(); }
                if(p == null && bve == null) { System.out.println("BooleanTest both null error"); }
                if(p != null && bve != null) { System.out.println("BooleanTest none null error"); }
        }
        public String eval(ArrayList<String> values, String tblName) {
          try {
                if(bve == null) return evalRecordWithPredicate(values, tblName, p);
                else return bve.eval(values, tblName);
         }
         catch (ParseException e)
    {
      System.out.println("Syntax error in eval...");
      parser = new SimpleDBMS(System.in);
      handleSyntaxError(parser);
      return "false";
    }
        }
        public String evalSel(ArrayList<String> values, ArrayList<String> tblNames) {
          try {
                if(bve == null) return evalWithPredicate(values, p, tblNames);
                else return bve.evalSel(values, tblNames);
         }
         catch (ParseException e)
    {
      System.out.println("Syntax error in eval...");
      parser = new SimpleDBMS(System.in);
      handleSyntaxError(parser);
      return "false";
    }
        }
}

class BooleanFactor {
        String not;
        BooleanTest bt;

        public BooleanFactor(String not, BooleanTest bt) {
                this.not = not;
                this.bt = bt;
        }
        public void print() {
                if(not != null) { System.out.print(not + " "); }
                bt.print();
        }
        public String eval(ArrayList<String> values, String tblName) {
          String result = bt.eval(values, tblName);
          if(not == null) {
            return result;
          }
          else {
            if(result.equals("true")) { return "false"; }
            else if(result.equals("false")) { return "true"; }
            else if(result.equals("unknown")) { return "unknown"; }
            else { System.out.println("BooleanFactor, result is not true or false or unknown error"); return "false";}
          }
        }
        public String evalSel(ArrayList<String> values, ArrayList<String> tblNames) {
          String result = bt.evalSel(values, tblNames);
          if(not == null) { return result; }
          else {
            if(result.equals("true")) { return "false"; }
            else if(result.equals("false")) { return "true"; }
            else if(result.equals("unknown")) { return "unknown"; }
            else { System.out.println("BooleanFactor evalSel, result is not true or false or unknown error"); return "false";}
          }
        }
}

class BooleanTerm {
        ArrayList<BooleanFactor> bfs;

        public BooleanTerm() {
                bfs = new ArrayList<BooleanFactor>();
        }
        public void print() {
                for(int i=0; i<bfs.size(); i++) {
                        bfs.get(i).print();
                }
        }
        // bf and bf and bf...
        public String eval(ArrayList<String> values, String tblName) {
          int trueCnt = 0;
          int falseCnt = 0;
          int unknownCnt = 0;
          for(BooleanFactor bfactor : bfs) {
            if(bfactor.eval(values, tblName).equals("true")) { trueCnt++; }
            else if(bfactor.eval(values, tblName).equals("false")) { falseCnt++; }
            else if(bfactor.eval(values, tblName).equals("unknown")) { unknownCnt++; }
            else { System.out.println("BooleanTerm, eval error"); return "false"; }
          }
          if(falseCnt != 0) return "false";
          if(unknownCnt != 0) return "unknown";
          return "true";
        }
        public String evalSel(ArrayList<String> values, ArrayList<String> tblNames) {
          int trueCnt = 0;
          int falseCnt = 0;
          int unknownCnt = 0;
          for(BooleanFactor bfactor : bfs) {
            if(bfactor.evalSel(values, tblNames).equals("true")) { trueCnt++; }
            else if(bfactor.evalSel(values, tblNames).equals("false")) { falseCnt++; }
            else if(bfactor.evalSel(values, tblNames).equals("unknown")) { unknownCnt++; }
            else { System.out.println("BooleanTerm, eval error"); return "false"; }
          }
          if(falseCnt != 0) return "false";
          if(unknownCnt != 0) return "unknown";
          return "true";
        }
}

class BooleanValueExpression {
        ArrayList<BooleanTerm> bts;

        public BooleanValueExpression() {
                bts = new ArrayList<BooleanTerm>();
        }
        public void print() {
                for(int i=0; i<bts.size(); i++) {
                        bts.get(i).print();
                }
        }
        // bt or bt or bt...
        public String eval(ArrayList<String> values, String tblName) {
          if(bts.size() == 0) return "true";
          int trueCnt = 0;
          int falseCnt = 0;
          int unknownCnt = 0;
          for (BooleanTerm bterm : bts) {
            if(bterm.eval(values, tblName).equals("true")) { trueCnt++; }
            else if(bterm.eval(values, tblName).equals("false")) { falseCnt++; }
            else if(bterm.eval(values, tblName).equals("unknown")) { unknownCnt++; }
            else { System.out.println("BooleanValueExpression, eval error"); return "false"; }
          }
          if(trueCnt != 0) return "true";
          if(unknownCnt != 0) return "unknown";
          return "false";
        }
        public String evalSel(ArrayList<String> values, ArrayList<String> tblNames) {
          if(bts.size() == 0) return "true";
          int trueCnt = 0;
          int falseCnt = 0;
          int unknownCnt = 0;
          for (BooleanTerm bterm : bts) {
            if(bterm.evalSel(values, tblNames).equals("true")) { trueCnt++; }
            else if(bterm.evalSel(values, tblNames).equals("false")) { falseCnt++; }
            else if(bterm.evalSel(values, tblNames).equals("unknown")) { unknownCnt++; }
            else { System.out.println("BooleanValueExpression, eval error"); return "false"; }
          }
          if(trueCnt != 0) return "true";
          if(unknownCnt != 0) return "unknown";
          return "false";
        }
}
  static final String [] keywordList = new String []
  {
    "exit",
    "create",
    "table",
    "not",
    "null",
    "primary",
    "key",
    "foreign",
    "references",
    "int",
    "char",
    "date",
    "drop",
    "show",
    "tables",
    "desc",
    "select",
    "as",
    "from",
    "where",
    "and",
    "or",
    "is",
    "insert",
    "into",
    "values",
    "delete"
  };

  static final Set<String> keywordSet = new HashSet<String> (Arrays.asList(keywordList));
  static myDatabase myDB = new myDatabase();
  static SimpleDBMS parser;
  static String tmpColDef = "";
  static String tmpPriKey = "";
  static String tmpForKey = "";
  static String delim = "|";
  static String createTblName = "";
  static String dropTblName = "";
  static Vector<String > tblNameList = new Vector<String >();

  public static void main(String args []) throws ParseException
  {
    myDB.openDB();
    parser = new SimpleDBMS(System.in);
    tblNameList = myDB.getDB("@table name");
    handleSyntaxError(parser);
  }

  public static void handleSyntaxError(SimpleDBMS parser)
  {
    try
    {
      parser.Start();
    }
    catch (ParseException e)
    {
      System.out.println("Syntax error");
      myDB.deleteTable(createTblName);
      parser = new SimpleDBMS(System.in);
      handleSyntaxError(parser);
    }
  }

  public static void handleDBError(SimpleDBMS parser)
  {
    parser = new SimpleDBMS(System.in);
    handleSyntaxError(parser);
  }

// Checking Functions
// Get column definition from DB and check duplicate columns
  final public boolean CheckDuplicateColumnDef(String tblName) throws ParseException {
    Vector<String> tmp = new Vector<String>();
    String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
    StringTokenizer st = new StringTokenizer(colDef, delim);
    while (st.hasMoreTokens())
    {
      String colName = st.nextToken();
      String colType = st.nextToken();
      if (tmp.contains(colName))
      {
        {if (true) return true;}
      }
      else
      {
        tmp.addElement(colName);
      }
    }
    {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

// Get table names from DB and check whether input table name exists in DB  final public boolean CheckTableExistence(String tblName) throws ParseException {
    Vector<String> tables = myDB.getDB("@table name");
    {if (true) return tables.contains(tblName);}
    throw new Error("Missing return statement in function");
  }

// Get primary key definition from this table and check whether it occurs more than one times  final public boolean CheckDuplicatePrimaryKeyDef(String tblName) throws ParseException {
    Vector<String> priKeys = myDB.getDB(tblName + " @primary key");
    {if (true) return priKeys.size() > 1;}
    throw new Error("Missing return statement in function");
  }

// Get primary key and foreign key definition from this table and check whether column names of this definition didn't occur in DB  final public String CheckNonExistingColumnDef(String tblName) throws ParseException {
    Vector<String> priKeys = myDB.getDB(tblName + " @primary key");
    Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");
    Vector<String> colNames = new Vector<String>();
    String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
    StringTokenizer st = new StringTokenizer(colDef, delim);
    while (st.hasMoreTokens())
    {
      String colName = st.nextToken();
      String colType = st.nextToken();
      colNames.addElement(colName);
    }
    // Check primary key definition
    if (priKeys.size() > 0)
    {
      String priKeyStr = priKeys.elementAt(0);
      StringTokenizer st2 = new StringTokenizer(priKeyStr, delim);
      while (st2.hasMoreTokens())
      {
        String colName = st2.nextToken();
        if (!colNames.contains(colName))
        {
          {if (true) return colName;}
        }
      }
    }
    // Check foreign key definition
    for (int i = 0; i < forKeys.size(); i++)
    {
      String forKeyStr = forKeys.elementAt(i);
      StringTokenizer st3 = new StringTokenizer(forKeyStr, delim);
      while (st3.hasMoreTokens())
      {
        String colName = st3.nextToken();
        if (colName.contains("references"))
        {
          break;
        }
        else if (!colNames.contains(colName))
        {
          {if (true) return colName;}
        }
      }
    }
    {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

// Get referenced table names from this table and check whether those referenced tables are really exist  final public boolean CheckReferenceTableExistence(String tblName) throws ParseException {
    Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");
    Vector<String> tblNames = myDB.getDB("@table name");
    String refTblName = "";
    for (int i = 0; i < forKeys.size(); i++)
    {
      String forKeyStr = forKeys.elementAt(i);
      StringTokenizer st = new StringTokenizer(forKeyStr, delim);
      while (st.hasMoreTokens())
      {
        refTblName = st.nextToken();
        if (refTblName.contains("references"))
        {
          refTblName = refTblName.substring(12);
          break;
        }
      }
      if (!tblNames.contains(refTblName))
      {
        {if (true) return true;}
      }
    }
    {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

// Get referenced columns from this table and check whether these columns are not primary key of referenced table  final public boolean CheckReferenceNonPrimaryKey(String tblName) throws ParseException {
    Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");
    String refTblName = "";
    for (int i = 0; i < forKeys.size(); i++)
    {
      // Get referenced columns
      String forKeyStr = forKeys.elementAt(i);
      StringTokenizer st = new StringTokenizer(forKeyStr, delim);
      Vector<String> refCols = new Vector<String>();
      Vector<String> refPriKeyCols = new Vector<String>();
      boolean isRefCol = false;
      while (st.hasMoreTokens())
      {
        String tmpstr = st.nextToken();
        if (tmpstr.contains("references"))
        {
          refTblName = tmpstr.substring(12);
          isRefCol = true;
          continue;
        }
        else if (isRefCol)
        {
          String refColName = tmpstr;
          refCols.addElement(refColName);
        }
      }
      Vector<String> refPriKeys = myDB.getDB(refTblName + " @primary key");
      if (refPriKeys.size() > 0)
      {
        // Get primary key of referenced table
        String refPriKeyStr = refPriKeys.elementAt(0);
        StringTokenizer st2 = new StringTokenizer(refPriKeyStr, delim);
        while (st2.hasMoreTokens())
        {
          String refPriKeyColName = st2.nextToken();
          refPriKeyCols.addElement(refPriKeyColName);
        }
      }
      // Check whether all of referenced columns are primary key
      for (int j = 0; j < refCols.size(); j++)
      {
        if (!refPriKeyCols.contains(refCols.elementAt(j)))
        {
          {if (true) return true;}
        }
      }
    }
    {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

// Get referenced columns from this table and check whether these columns are really exist in referenced table  final public boolean CheckReferenceColumnExistence(String tblName) throws ParseException {
    Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");
    String refTblName = "";
    for (int i = 0; i < forKeys.size(); i++)
    {
      // Get referenced columns
      String forKeyStr = forKeys.elementAt(i);
      StringTokenizer st = new StringTokenizer(forKeyStr, delim);
      Vector<String> refCols = new Vector<String>();
      boolean isRefCol = false;
      while (st.hasMoreTokens())
      {
        String tmpstr = st.nextToken();
        if (tmpstr.contains("references"))
        {
          refTblName = tmpstr.substring(12);
          isRefCol = true;
          continue;
        }
        else if (isRefCol)
        {
          String refColName = tmpstr;
          refCols.addElement(refColName);
        }
      }
      String refRealColDefStr = myDB.getDB(refTblName + " @column definition").elementAt(0);
      Vector<String> refRealColNames = new Vector<String>();
      StringTokenizer st2 = new StringTokenizer(refRealColDefStr, delim);
      // Get columns of referenced table
      while (st2.hasMoreTokens())
      {
        String colName = st2.nextToken();
        String colType = st2.nextToken();
        refRealColNames.addElement(colName);
      }
      // Check whether all of referenced columns exist in referenced table
      for (int j = 0; j < refCols.size(); j++)
      {
        if (!refRealColNames.contains(refCols.elementAt(j)))
        {
          {if (true) return true;}
        }
      }
    }
    {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

// Get type of referenced columns and referencing columns and check whether types of both columns are same  final public boolean CheckReferenceType(String tblName) throws ParseException {
    Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");
    for (int i = 0; i < forKeys.size(); i++)
    {
      // Get referenced columns and referencing columns
      String forKeyStr = forKeys.elementAt(i);
      StringTokenizer st = new StringTokenizer(forKeyStr, delim);
      Vector<String> forCols = new Vector<String>();
      Vector<String> refCols = new Vector<String>();
      String refTblName = "";
      boolean isRefCol = false;
      while (st.hasMoreTokens())
      {
        String tmpstr = st.nextToken();
        if (tmpstr.contains("references"))
        {
          refTblName = tmpstr.substring(12);
          isRefCol = true;
          continue;
        }
        else if (isRefCol)
        {
          String refColName = tmpstr;
          refCols.addElement(refColName);
        }
        else
        {
          String forColName = tmpstr;
          forCols.addElement(forColName);
        }
      }
      // If number of referenced columns and referencing columns are different, type error
      if (refCols.size() != forCols.size())
      {
        {if (true) return true;}
      }
      // Check type of these columns one by one
      else
      {
        for (int j = 0; j < refCols.size(); j++)
        {
          String forColType = GetColumnType(tblName, forCols.elementAt(j));
          String refColType = GetColumnType(refTblName, refCols.elementAt(j));
          if (!forColType.equals(refColType))
          {
            {if (true) return true;}
          }
        }
      }
    }
    {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

// Get table names of DB and check whether this table exists  final public boolean CheckNoSuchTable(String tblName) throws ParseException {
    Vector<String> tblNames = myDB.getDB("@table name");
    {if (true) return !tblNames.contains(tblName);}
    throw new Error("Missing return statement in function");
  }

// Get referenced table names of DB and check whether this table is referenced by other table  final public boolean CheckDropReferencedTable(String refTblName) throws ParseException {
    Vector<String> tblNames = myDB.getDB("@table name");
    for (int i = 0; i < tblNames.size(); i++)
    {
      Vector<String> forKeys = myDB.getDB(tblNames.elementAt(i) + " @foreign key");
      for (int j = 0; j < forKeys.size(); j++)
      {
        String forKeyStr = forKeys.elementAt(j);
        StringTokenizer st = new StringTokenizer(forKeyStr, delim);
        String tmpTbl = "";
        while (st.hasMoreTokens())
        {
          String tmp = st.nextToken();
          if (tmp.contains("references"))
          {
            tmpTbl = tmp.substring(12);
            break;
          }
        }
        if (tmpTbl.equals(refTblName))
        {
          {if (true) return true;}
        }
      }
    }
    {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

// Check whether there is no table  final public boolean CheckShowTablesNoTable() throws ParseException {
    Vector<String> tblNames = myDB.getDB("@table name");
    {if (true) return (tblNames.size() == 0);}
    throw new Error("Missing return statement in function");
  }

// Error Functions
  final public void DuplicateColumnDefError(String tblName) throws ParseException {
    System.out.println("Create table has failed: column definition is duplicated");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void TableExistenceError() throws ParseException {
    System.out.println("Create table has failed: table with the same name already exist");
    handleDBError(parser);
  }

  final public void CharLengthError() throws ParseException {
    System.out.println("Char length should be > 0");
    handleDBError(parser);
  }

  final public void DuplicatePrimaryKeyDefError(String tblName) throws ParseException {
    System.out.println("Create table has failed: primary key definition is duplicated");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void NonExistingColumnDefError(String tblName, String colName) throws ParseException {
    System.out.println("Create table has failed: '" + colName + "' does not exists in column definition");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void ReferenceTableExistenceError(String tblName) throws ParseException {
    System.out.println("Create table has failed: foreign key references non existing table");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void ReferenceNonPrimaryKeyError(String tblName) throws ParseException {
    System.out.println("Create table has failed: foreign key references non primary key column");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void ReferenceColumnExistenceError(String tblName) throws ParseException {
    System.out.println("Create table has failed: foreign key references non existing column");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void ReferenceTypeError(String tblName) throws ParseException {
    System.out.println("Create table has failed: foreign key references wrong type");
    myDB.deleteTable(tblName);
    handleDBError(parser);
  }

  final public void NoSuchTable() throws ParseException {
    System.out.println("No such table");
    handleDBError(parser);
  }

  final public void DropReferencedTableError(String tblName) throws ParseException {
    System.out.println("Drop table has failed: '" + tblName + "' is referenced by other table");
    handleDBError(parser);
  }

  final public void ShowTablesNoTable() throws ParseException {
    System.out.println("There is no table");
    handleDBError(parser);
  }

// Utility Functions
// Get type of column
  final public String GetColumnType(String tblName, String colName) throws ParseException {
    String colDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);
    StringTokenizer st = new StringTokenizer(colDefStr, delim);
    while (st.hasMoreTokens())
    {
      String _colName = st.nextToken();
      String colType = st.nextToken();
      if (colName.equals(_colName))
      {
        StringTokenizer st2 = new StringTokenizer(colType, "*");
        {if (true) return st2.nextToken();}
      }
    }
    {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

// Change columns of primary key to not null
  final public void ChangeToNotNull(String tblName) throws ParseException {
    Vector<String> priKeys = myDB.getDB(tblName + " @primary key");
    if (priKeys.size() > 0)
    {
      // Get primary keys
      Vector<String> priCols = new Vector<String>();
      String priKeyStr = priKeys.elementAt(0);
      String colDefStr = myDB.getDB(tblName + " @column definition").elementAt(0);
      myDB.deleteDB(tblName + " @column definition");
      StringTokenizer st = new StringTokenizer(priKeyStr, delim);
      while (st.hasMoreTokens())
      {
        priCols.addElement(st.nextToken());
      }
      StringTokenizer st2 = new StringTokenizer(colDefStr, delim);
      String newColDef = "";
      // Change type of primary keys to not null by deleting and re-inserting primary key data
      while (st2.hasMoreTokens())
      {
        String colName = st2.nextToken();
        String colType = st2.nextToken();
        StringTokenizer st3 = new StringTokenizer(colType, "*");
        String realColType = st3.nextToken();
        if (priCols.contains(colName) && !st3.hasMoreTokens())
        {
          newColDef += "|" + colName + "|" + realColType + "*not null";
        }
        else
        {
          newColDef += "|" + colName + "|" + colType;
        }
      }
      myDB.putDB(tblName + " @column definition", newColDef.substring(1));
    }
  }

// Perform drop table query  final public void DropTable(String tblName) throws ParseException {
    myDB.deleteTable(tblName);
    myDB.deleteDB("@table name");
    tblNameList.remove(tblName);
    for (int i = 0; i < tblNameList.size(); i++)
    {
      myDB.putDB("@table name", tblNameList.elementAt(i));
    }
  }

// Perform show tables query  final public void ShowTables() throws ParseException {
    Vector<String> tblNames = myDB.getDB("@table name");
    System.out.println("-------------------------");
    for (int i = 0; i < tblNames.size(); i++)
    {
      System.out.println(tblNames.elementAt(i));
    }
    System.out.println("-------------------------");
  }

// Check whether given column is primary key column
  final public boolean IsPrimaryKey(String tblName, String colName) throws ParseException {
    Vector<String> priKeys = myDB.getDB(tblName + " @primary key");
    if (priKeys.size() > 0)
    {
      String priKeyStr = priKeys.elementAt(0);
      StringTokenizer st = new StringTokenizer(priKeyStr, delim);
      while (st.hasMoreTokens())
      {
        String tmp = st.nextToken();
        if (tmp.equals(colName))
        {
          {if (true) return true;}
        }
      }
    }
    {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

// Check whether given column is foreign key column  final public boolean IsForeignKey(String tblName, String colName) throws ParseException {
    Vector<String> forKeys = myDB.getDB(tblName + " @foreign key");
    for (int i = 0; i < forKeys.size(); i++)
    {
      String forKeyStr = forKeys.elementAt(i);
      StringTokenizer st = new StringTokenizer(forKeyStr, delim);
      while (st.hasMoreTokens())
      {
        String tmp = st.nextToken();
        if (tmp.contains("references"))
        {
          break;
        }
        else if (tmp.equals(colName))
        {
          {if (true) return true;}
        }
      }
    }
    {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

// Perform desc query
  final public void Describe(String tblName) throws ParseException {
    String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
    StringTokenizer st = new StringTokenizer(colDef, delim);
    System.out.println("------------------------------------------------------------");
    System.out.println("table_name [" + tblName + "]");
    System.out.printf("%-25s%-15s%-10s%-10s\u005cn", "column_name", "type", "null", "key");
    while (st.hasMoreTokens())
    {
      String colName = st.nextToken();
      String colType = st.nextToken();
      boolean isNotNull = false;
      boolean isPriKey = IsPrimaryKey(tblName, colName);
      boolean isForKey = IsForeignKey(tblName, colName);
      StringTokenizer st2 = new StringTokenizer(colType, "*");
      String realColType = st2.nextToken();
      if (st2.hasMoreTokens())
      {
        isNotNull = true;
      }
      System.out.printf("%-25s%-15s", colName, realColType);
      if (isNotNull)
      {
        System.out.printf("%-10s", "N");
      }
      else
      {
        System.out.printf("%-10s", "Y");
      }
      if (isPriKey && isForKey)
      {
        System.out.printf("%-10s\u005cn", "PRI/FOR");
      }
      else if (isPriKey)
      {
        System.out.printf("%-10s\u005cn", "PRI");
      }
      else if (isForKey)
      {
        System.out.printf("%-10s\u005cn", "FOR");
      }
      else
      {
        System.out.print("\u005cn");
      }
    }
    System.out.println("------------------------------------------------------------");
  }

// Success Functions
  final public void CreateTableSuccess() throws ParseException {
    System.out.println("'" + createTblName + "' table is created");
  }

  final public void DropSuccess() throws ParseException {
    System.out.println("'" + dropTblName + "' table is dropped");
  }

  final public void InsertSuccess() throws ParseException {
    System.out.println("The row is inserted");
  }

  final public void DeleteSuccess() throws ParseException {
    System.out.println();
  }

// Parsing Functions
  final public void Command() throws ParseException {
    QueryList();
  }

  final public void QueryList() throws ParseException {
  int i;
    label_1:
    while (true) {
      i = Query();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
          Success(i);
        break;
      case 1:
      case 2:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 1:
          jj_consume_token(1);
          break;
        case 2:
          jj_consume_token(2);
          break;
        default:
          jj_la1[0] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
          Success(i);
          System.out.print("DB_2012-11249 > ");
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXIT:
      case RECORDS:
      case DELETE_AT:
      case CREATE_TABLE:
      case DROP_TABLE:
      case SHOW_TABLES:
      case DESC:
      case SELECT:
      case INSERT_INTO:
      case DELETE_FROM:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_1;
      }
    }
  }

  final public int Query() throws ParseException {
  int i;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CREATE_TABLE:
      i = CreateTableQuery();
      break;
    case DROP_TABLE:
      i = DropTableQuery();
      break;
    case SHOW_TABLES:
      i = ShowTablesQuery();
      break;
    case DESC:
      i = DescQuery();
      break;
    case SELECT:
      i = SelectQuery();
      break;
    case INSERT_INTO:
      i = InsertQuery();
      break;
    case DELETE_FROM:
      i = DeleteQuery();
      break;
    case RECORDS:
      i = RecordsQuery();
      break;
    case DELETE_AT:
      i = DeleteatQuery();
      break;
    case EXIT:
      i = ExitQuery();
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return i;}
    throw new Error("Missing return statement in function");
  }

//jaewan start
// helper query
// print all records of table
// ex) records student;
  final public int RecordsQuery() throws ParseException {
  String tblName;
    jj_consume_token(RECORDS);
    tblName = TableName();
    showRecords(tblName);
    {if (true) return 500;}
    throw new Error("Missing return statement in function");
  }

  final public void showRecords(String tblName) throws ParseException {
    Vector<String> records = myDB.getDB(tblName + " @records");
    System.out.println(tblName + "'s records start");
    for(int i=0; i<records.size(); i++) {
      System.out.println(records.get(i));
    }
    System.out.println("#of records: " + records.size());
    System.out.println(tblName + "'s records end");
    {if (true) return;}
  }

// helper query
// delete nth records at table
// ex)deleteat student +3;
  final public int DeleteatQuery() throws ParseException {
  String tblName;
  Token t;
    jj_consume_token(DELETE_AT);
    tblName = TableName();
    t = jj_consume_token(INT_VALUE);
    deleteAt(tblName, t.image.toLowerCase());
    {if (true) return 500;}
    throw new Error("Missing return statement in function");
  }

  final public void deleteAt(String tblName, String index) throws ParseException {
        int deleteIndex = Integer.parseInt(index);
        Vector<String> records = myDB.getDB(tblName + " @records");
        myDB.deleteDB(tblName + " @records");
        for(int i=0; i<records.size(); i++) {
          if(i != deleteIndex) {
            myDB.putDB(tblName + " @records", records.elementAt(i));
          }
        }
        System.out.println("delete " + deleteIndex + "th row completed");
  }

//jaewan end  final public int ExitQuery() throws ParseException {
    jj_consume_token(EXIT);
    {if (true) return - 1;}
    throw new Error("Missing return statement in function");
  }

  final public int CreateTableQuery() throws ParseException {
  String tblName;
  String colName;
    jj_consume_token(CREATE_TABLE);
    tblName = TableName();
    if (CheckTableExistence(tblName))
    {
      TableExistenceError();
    }
    TableElementList(tblName);
    myDB.putDB(tblName + " @column definition", tmpColDef.substring(1));
    tmpColDef = "";
    tmpPriKey = "";
    tmpForKey = "";
    if (CheckDuplicateColumnDef(tblName))
    {
      DuplicateColumnDefError(tblName);
    }
    else if (CheckDuplicatePrimaryKeyDef(tblName))
    {
      DuplicatePrimaryKeyDefError(tblName);
    }
    else if ((colName = CheckNonExistingColumnDef(tblName)) != null)
    {
      NonExistingColumnDefError(tblName, colName);
    }
    else if (CheckReferenceTableExistence(tblName))
    {
      ReferenceTableExistenceError(tblName);
    }
    else if (CheckReferenceColumnExistence(tblName))
    {
      ReferenceColumnExistenceError(tblName);
    }
    else if (CheckReferenceNonPrimaryKey(tblName))
    {
      ReferenceNonPrimaryKeyError(tblName);
    }
    else if (CheckReferenceType(tblName))
    {
      ReferenceTypeError(tblName);
    }
    ChangeToNotNull(tblName);
    createTblName = tblName;
    myDB.putDB("@table name", tblName);
    tblNameList.addElement(tblName);
    {if (true) return 0;}
    throw new Error("Missing return statement in function");
  }

  final public void TableElementList(String tblName) throws ParseException {
    jj_consume_token(LEFT_PAREN);
    TableElement(tblName);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_2;
      }
      jj_consume_token(COMMA);
      TableElement(tblName);
    }
    jj_consume_token(RIGHT_PAREN);
  }

  final public void TableElement(String tblName) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ALPHABET:
    case LEGAL_IDENTIFIER:
      ColumnDefinition();
      break;
    case PRIMARY_KEY:
    case FOREIGN_KEY:
      TableConstraintDefinition(tblName);
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ColumnDefinition() throws ParseException {
  String colName = "";
  String dataType = "";
  String notNull = "";
    if (jj_2_1(2147483647)) {
      colName = ColumnName();
      dataType = DataType();
      jj_consume_token(NOT_NULL);
        notNull = "*not null";
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:
        colName = ColumnName();
        dataType = DataType();
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    tmpColDef += delim + colName + delim + dataType + notNull;
  }

  final public void TableConstraintDefinition(String tblName) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMARY_KEY:
      PrimaryKeyConstraint(tblName);
      break;
    case FOREIGN_KEY:
      ReferentialKeyConstraint(tblName);
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void PrimaryKeyConstraint(String tblName) throws ParseException {
    jj_consume_token(PRIMARY_KEY);
    ColumnNameList(true);
    myDB.putDB(tblName + " @primary key", tmpPriKey.substring(1));
  }

  final public void ReferentialKeyConstraint(String tblName) throws ParseException {
  String referedTblName;
  String tempstr;
  String[] tmp_strs;
    jj_consume_token(FOREIGN_KEY);
    ColumnNameList(false);
    jj_consume_token(REFERENCES);
    referedTblName = TableName();
    tmpForKey += delim + "@references&" + referedTblName;
    ColumnNameList(false);
    myDB.putDB(tblName + " @foreign key", tmpForKey.substring(1));
    tmpForKey = "";
  }

  final public void ColumnNameList(boolean isPrimaryKey) throws ParseException {
  String colName;
    jj_consume_token(LEFT_PAREN);
    colName = ColumnName();
    if (isPrimaryKey)
    {
      tmpPriKey += delim + colName;
    }
    else
    {
      tmpForKey += delim + colName;
    }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_3;
      }
      jj_consume_token(COMMA);
      colName = ColumnName();
      if (isPrimaryKey)
      {
        tmpPriKey += delim + colName;
      }
      else
      {
        tmpForKey += delim + colName;
      }
    }
    jj_consume_token(RIGHT_PAREN);
  }

  final public String DataType() throws ParseException {
  Token size;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      jj_consume_token(INT);
    {if (true) return "int";}
      break;
    case CHAR:
      jj_consume_token(CHAR);
      jj_consume_token(LEFT_PAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT_VALUE:
        size = jj_consume_token(INT_VALUE);
        break;
      case DIGIT:
        size = jj_consume_token(DIGIT);
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RIGHT_PAREN);
      if (Integer.parseInt(size.image) <= 0) CharLengthError();
      {if (true) return "char(" + Integer.toString(Integer.parseInt(size.image)) + ")";}
      break;
    case DATE:
      jj_consume_token(DATE);
    {if (true) return "date";}
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String TableName() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEGAL_IDENTIFIER:
      t = jj_consume_token(LEGAL_IDENTIFIER);
      if (IsKeyword(t.image))
      {
        {if (true) throw new ParseException();}
      }
      break;
    case ALPHABET:
      t = jj_consume_token(ALPHABET);
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return t.image.toLowerCase();}
    throw new Error("Missing return statement in function");
  }

  final public String ColumnName() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEGAL_IDENTIFIER:
      t = jj_consume_token(LEGAL_IDENTIFIER);
      if (IsKeyword(t.image))
      {
        {if (true) throw new ParseException();}
      }
      break;
    case ALPHABET:
      t = jj_consume_token(ALPHABET);
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return t.image.toLowerCase();}
    throw new Error("Missing return statement in function");
  }

  final public int DropTableQuery() throws ParseException {
  String tblName;
    jj_consume_token(DROP_TABLE);
    tblName = TableName();
    if (CheckNoSuchTable(tblName))
    {
      NoSuchTable();
    }
    else if (CheckDropReferencedTable(tblName))
    {
      DropReferencedTableError(tblName);
    }
    else
    {
      dropTblName = tblName;
      DropTable(tblName);
    }
    {if (true) return 1;}
    throw new Error("Missing return statement in function");
  }

  final public int ShowTablesQuery() throws ParseException {
    jj_consume_token(SHOW_TABLES);
    if (CheckShowTablesNoTable())
    {
      ShowTablesNoTable();
    }
    else
    {
      ShowTables();
    }
    {if (true) return 2;}
    throw new Error("Missing return statement in function");
  }

  final public int DescQuery() throws ParseException {
  String tblName;
    jj_consume_token(DESC);
    tblName = TableName();
    if (CheckNoSuchTable(tblName))
    {
      NoSuchTable();
    }
    else
    {
      Describe(tblName);
    }
    {if (true) return 3;}
    throw new Error("Missing return statement in function");
  }

  final public String CheckSelectTableExistenceError(TableExpression tbe) throws ParseException {
    ArrayList<String> trl = tbe.tableReferenceList;
    Vector<String> existTblNames = myDB.getDB("@table name");
    for(String tblName : trl) {
      if(!existTblNames.contains(tblName)) { {if (true) return tblName;} }
    }

    {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public String CheckSelectColumnResolveError(ArrayList<String> scl, TableExpression tbe) throws ParseException {
    if(scl.get(0).equals("*")) { {if (true) return null;} }
    ArrayList<String> trl = tbe.tableReferenceList;

    for(String colName : scl) {
      // colName = < tableName >.< columnName >
      if(split(colName, ".").size() == 2) {
                String tn = split(colName, ".").get(0);
                String cn = split(colName, ".").get(1);

                if(!trl.contains(tn)) { {if (true) return colName;} }

                String colDef = myDB.getDB(tn + " @column definition").elementAt(0);
                ArrayList<String> existColumns = getColumns(colDef, "name");
                if(!existColumns.contains(cn)) { {if (true) return colName;} }
      }
      // colName = < columnName >
      else {
        int refCnt = findColumnMatchCount(trl, null, colName);
        if(refCnt != 1) { {if (true) return colName;} }
      }
    }

    {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<String> _cartesian(ArrayList<String> rec1, ArrayList<String> rec2) throws ParseException {
        ArrayList<String> result = new ArrayList<String>();
        for(String s1 : rec1) {
          for(String s2 : rec2) {
            result.add(s1 + s2);
          }
        }

        {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<String> vectorToList(Vector<String> v) throws ParseException {
    ArrayList<String> result = new ArrayList<String>();
    for(String s : v) { result.add(s); }
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<String> cartesian(ArrayList<String> tblNames) throws ParseException {
    ArrayList<String> result;
    Vector<String> records = myDB.getDB(tblNames.get(0) + " @records");
    result = vectorToList(records);
    if(tblNames.size() == 1) { {if (true) return result;} }

    for(int i=1; i<tblNames.size(); i++) {
      String tblName = tblNames.get(i);
      Vector<String> _records = myDB.getDB(tblName + " @records");
      ArrayList<String> temp = vectorToList(_records);
      result = _cartesian(result, temp);
    }

    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public int findIndex(ArrayList<String> tblNames, String columnAux, String columnName) throws ParseException {
    if(columnAux != null) {
      String tblName = split(columnAux, ".").get(0);
      String colName = split(columnAux, ".").get(1);
      int innerIndex = 0;
      int resultIndex = 0;

      String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
      ArrayList<String> existColumns = getColumns(colDef, "name");
      // find inner index
      for(int i=0; i<existColumns.size(); i++) {
        if(existColumns.get(i).equals(colName)) {
          innerIndex = i;
          break;
        }
      }

      for(int i=0; i<tblNames.size(); i++) {
        if(!tblNames.get(i).equals(tblName)) {
          String _colDef = myDB.getDB(tblNames.get(i) + " @column definition").elementAt(0);
          ArrayList<String> _existColumns = getColumns(_colDef, "name");
          resultIndex += _existColumns.size();
        }
        else { break; }
      }

      {if (true) return resultIndex + innerIndex;}

    }
    else {
      int resultIndex = 0;
      for(String tblName : tblNames) {
        String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
        ArrayList<String> existColumns = getColumns(colDef, "name");
        for(int i=0; i<existColumns.size(); i++) {
          if(existColumns.get(i).equals(columnName)) {
            break;
          }
          else {
            resultIndex++;
          }
        }
      }

      {if (true) return resultIndex;}
    }
    throw new Error("Missing return statement in function");
  }

  final public String coToValue(ArrayList<String> values, ArrayList<String> tableNames, CompOperand co) throws ParseException {
    if(co.comparableValue != null) {
      {if (true) return co.comparableValue;}
    }
    else {
      int index = findIndex(tableNames, co.compOperandAux, co.columnName);
      {if (true) return values.get(index);}
    }
    throw new Error("Missing return statement in function");
  }

  final public String evalWithPredicate(ArrayList<String> values, Predicate p, ArrayList<String> tableNames) throws ParseException {
    //int findIndex(ArrayList<String> tblNames, String columnAux, String columnName)

        // comparison predicate
    if(p.cp != null) {
      CompOperand co1 = p.cp.co1;
      CompOperand co2 = p.cp.co2;
      String compOp = p.cp.compOp;

      String value1 = coToValue(values, tableNames, co1);
      String value2 = coToValue(values, tableNames, co2);
      // compare value1, value2
      if(value1.equals("null") || value2.equals("null")) {
                // unknown 
        {if (true) return "unknown";}
      } else {
        String valueType = split(value1, ":").get(0);
        String value1Value = split(value1, ":").get(1);
        String value2Value = split(value2, ":").get(1);

        if(valueType.equals("num")) {
          int _value1 = Integer.parseInt(value1Value);
          int _value2 = Integer.parseInt(value2Value);
          if(compOp.equals("<")) { {if (true) return _value1 < _value2 ? "true" : "false";} }
          else if(compOp.equals(">")) { {if (true) return _value1 > _value2 ? "true" : "false";} }
          else if(compOp.equals("<=")) { {if (true) return _value1 <= _value2 ? "true" : "false";} }
          else if(compOp.equals(">=")) { {if (true) return _value1 >= _value2 ? "true" : "false";} }
          else if(compOp.equals("!=")) { {if (true) return _value1 != _value2 ? "true" : "false";} }
          else { {if (true) return _value1 == _value2 ? "true" : "false";} }
        }

        else if(valueType.equals("str")) {
          // trim ''
          String _value1 = value1Value.substring(1, value1Value.length());
          String _value2 = value2Value.substring(1, value2Value.length());

          int compResult = _value1.compareTo(_value2);
          if(compOp.equals("<")) { {if (true) return compResult < 0 ? "true" : "false";}}
          else if(compOp.equals(">")) { {if (true) return compResult > 0 ? "true" : "false";} }
          else if(compOp.equals("<=")) { {if (true) return compResult <= 0 ? "true" : "false";}}
          else if(compOp.equals(">=")) { {if (true) return compResult >= 0 ? "true" : "false";}}
          else if(compOp.equals("!=")) { {if (true) return compResult != 0 ? "true" : "false";}}
          else { {if (true) return compResult == 0 ? "true" : "false";}}
        }

        else if(valueType.equals("date")) {
          int compResult = value1.compareTo(value2);
          if(compOp.equals("<")) { {if (true) return compResult < 0 ? "true" : "false";}}
          else if(compOp.equals(">")) { {if (true) return compResult > 0 ? "true" : "false";} }
          else if(compOp.equals("<=")) { {if (true) return compResult <= 0 ? "true" : "false";}}
          else if(compOp.equals(">=")) { {if (true) return compResult >= 0 ? "true" : "false";}}
          else if(compOp.equals("!=")) { {if (true) return compResult != 0 ? "true" : "false";}}
          else { {if (true) return compResult == 0 ? "true" : "false";}}
        }
        // value type error case
        else {
          //System.out.println("evalRecords, comparable value type error");
          {if (true) return "false";}
        }
      }
    }
    // null predicate
    else {
      String nullOperation = p.np.nullOperation;
      int index = findIndex(tableNames, p.np.nullPredicateAux, p.np.columnName);
      String value = values.get(index);

      if(nullOperation.equals("is null")) {
        {if (true) return value.equals("null") ? "true" : "false";}
      }
      else {
        {if (true) return !value.equals("null") ? "true" : "false";}
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public void realSelect(ArrayList<String> selectedColumnList, TableExpression tbe) throws ParseException {
    ArrayList<String> trl = tbe.tableReferenceList;
    BooleanValueExpression bve = tbe.bve;
    ArrayList<String> bigRecords = cartesian(trl);
    ArrayList<String> result = new ArrayList<String>();

    for(String record : bigRecords) {
      ArrayList<String> values = split(record, "|");
      String bveResult;

      if(bve == null) { bveResult = "true"; }
      else { bveResult = bve.evalSel(values, trl); }

      if(bveResult.equals("true")) { result.add(record); }
    }

    projection(result, selectedColumnList, trl);
    {if (true) return;}
  }

  final public ArrayList<Integer> projIndex(ArrayList<String> scl, ArrayList<String> trl) throws ParseException {
    ArrayList<Integer> result = new ArrayList<Integer>();
    for(String selected : scl) {
      ArrayList<String> temp = split(selected, ".");
      if(temp.size() == 2) { result.add(findIndex(trl, selected, null)); }
      else { result.add(findIndex(trl, null, selected)); }
    }

    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public void projection(ArrayList<String> result, ArrayList<String> scl, ArrayList<String> trl) throws ParseException {
    // print all
    if(scl.get(0).equals("*")) {
      // 1st line
      for(String tblName : trl) {
        String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
        ArrayList<String> existColumns = getColumns(colDef, "name");

        for(String colName : existColumns) { System.out.print("+--------------------");}
      }
      System.out.println("+");


      // colName duplicate check helper
      HashMap<String, Integer> colNameHash = new HashMap<String, Integer>();
      ArrayList<String> commonColNames = new ArrayList<String>();
      for(String tblName : trl) {
        String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
        ArrayList<String> existColumns = getColumns(colDef, "name");

        for(String colName : existColumns) {
          if(colNameHash.get(colName) == null) { colNameHash.put(colName, 1); }
          else { int tempCnt = colNameHash.get(colName); colNameHash.put(colName, tempCnt+1); }
        }
      }

      // 2nd line, column names;
      for(String tblName : trl) {
        String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
        ArrayList<String> existColumns = getColumns(colDef, "name");

        for(String colName : existColumns) {
          int len = colName.length();

          if(colNameHash.get(colName) > 1) { System.out.print("| " + tblName + "." + colName); len += tblName.length()+1; }
          else { System.out.print("| " + colName); }
          for(int i=0; i<19-len; i++) { System.out.print(" "); }
        }
      }
      System.out.println("|");

      // 3rd line
      for(String tblName : trl) {
        String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
        ArrayList<String> existColumns = getColumns(colDef, "name");

        for(String colName : existColumns) { System.out.print("+--------------------");}
      }
      System.out.println("+");


      // records
      for(String s : result) {
        ArrayList<String> values = split(s, "|");
        for(int i=0; i<values.size(); i++) {
          String value = values.get(i);
          int len = value.length();
          System.out.print("| " + value);
          for(int j=0; j<19-len; j++) { System.out.print(" "); }
        }
        System.out.println("|");
      }


      // last line
      for(String tblName : trl) {
        String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
        ArrayList<String> existColumns = getColumns(colDef, "name");

        for(String colName : existColumns) { System.out.print("+--------------------");}
      }
      System.out.println("+");

    }
        // print scl
    else {
      ArrayList<Integer> index = projIndex(scl, trl);
      // 1st line
      for(int i=0; i<index.size(); i++) { System.out.print("+--------------------"); }
      System.out.println("+");

      // 2nd lint
      for(String selected : scl) {
        System.out.print("| " + selected);
        int len = selected.length();
        for(int i=0; i<19-len; i++) { System.out.print(" "); }
      }
      System.out.println("|");

      // 3rd line
      for(int i=0; i<index.size(); i++) { System.out.print("+--------------------"); }
      System.out.println("+");

      // records
      for(String s : result) {
        ArrayList<String> values = split(s, "|");
        for(int i=0; i<index.size(); i++) {
          String value = values.get(index.get(i));
          System.out.print("| " + value);
          int len = value.length();
          for(int j=0; j<19-len; j++) { System.out.print(" "); }
        }
        System.out.println("|");
      }


      // last line
      for(int i=0; i<index.size(); i++) { System.out.print("+--------------------"); }
      System.out.println("+");

    }

    {if (true) return;}
  }

  final public int SelectQuery() throws ParseException {
  ArrayList<String> scl; TableExpression tbe;  String s;
    jj_consume_token(SELECT);
    scl = SelectList();
    tbe = TableExpression();
    ArrayList<String> tblNames = tbe.tableReferenceList;
    BooleanValueExpression bve = tbe.bve;
    if((s = CheckSelectTableExistenceError(tbe)) != null) {
      System.out.println("Selection has failed: '" + s + "' does not exist");
      handleDBError(parser);
    }
    else if((s = CheckSelectColumnResolveError(scl, tbe)) != null) {
      System.out.println("Selection has failed: fail to resolve '" + s + "'");
      handleDBError(parser);
    }
    else if(CheckWhereTableNotSpecifiedError(tblNames, bve)) {
                System.out.println("Where clause try to reference tables which are not specified");
                handleDBError(parser);
        }
        else if(CheckWhereColumnNotExistError(tblNames, bve)) {
                System.out.println("Where clause try to reference non existing column");
                handleDBError(parser);
        }
        else if(CheckWhereAmbiguousReferenceError(tblNames, bve)) {
                System.out.println("Where clause contains ambiguous reference");
                handleDBError(parser);
        }
    else if(CheckWhereIncomparableError(tblNames, bve)) {
                System.out.println("Where clause try to compare incomparable values");
                handleDBError(parser);
    }

    // selece start
    realSelect(scl, tbe);
    {if (true) return 4;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<String> SelectList() throws ParseException {
  ArrayList<String> selectedColumnList = new ArrayList<String>();
  String colName;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 3:
      jj_consume_token(3);
        selectedColumnList.add("*"); {if (true) return selectedColumnList;}
      break;
    case ALPHABET:
    case LEGAL_IDENTIFIER:
      colName = SelectedColumn();
                                 selectedColumnList.add(colName);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[13] = jj_gen;
          break label_4;
        }
        jj_consume_token(COMMA);
        colName = SelectedColumn();
                                             selectedColumnList.add(colName);
      }
      {if (true) return selectedColumnList;}
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String SelectedColumn() throws ParseException {
  String colName;
    if (jj_2_2(2147483647)) {
      colName = SelectedColumnAux1();
                                   {if (true) return colName;}
    } else if (jj_2_3(2147483647)) {
      colName = SelectedColumnAux2();
                                   {if (true) return colName;}
    } else if (jj_2_4(2147483647)) {
      colName = SelectedColumnAux3();
                                   {if (true) return colName;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:
        colName = ColumnName();
                           {if (true) return colName;}
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public String SelectedColumnAux1() throws ParseException {
  String tn; String cn1; String cn2;
    tn = TableName();
    jj_consume_token(PERIOD);
    cn1 = ColumnName();
    jj_consume_token(AS);
    cn2 = ColumnName();
    {if (true) return tn + "." + cn1 + "@as@" + cn2;}
    throw new Error("Missing return statement in function");
  }

  final public String SelectedColumnAux2() throws ParseException {
  String tn; String cn;
    tn = TableName();
    jj_consume_token(PERIOD);
    cn = ColumnName();
    {if (true) return tn + "." + cn;}
    throw new Error("Missing return statement in function");
  }

  final public String SelectedColumnAux3() throws ParseException {
  String cn1; String cn2;
    cn1 = ColumnName();
    jj_consume_token(AS);
    cn2 = ColumnName();
    {if (true) return cn1 + "@as@" + cn2;}
    throw new Error("Missing return statement in function");
  }

  final public TableExpression TableExpression() throws ParseException {
  TableExpression tbe = new TableExpression(null, null);
  ArrayList<String> trl;
  BooleanValueExpression bve;
    if (jj_2_5(2147483647)) {
      trl = FromClause();
      bve = WhereClause();
                                           tbe.tableReferenceList = trl; tbe.bve = bve; {if (true) return tbe;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FROM:
        trl = FromClause();
                       tbe.tableReferenceList = trl; {if (true) return tbe;}
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<String> FromClause() throws ParseException {
  ArrayList<String> trl;
    jj_consume_token(FROM);
    trl = TableReferenceList();
                                        {if (true) return trl;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<String> TableReferenceList() throws ParseException {
  ArrayList<String> trl = new ArrayList<String>();
  String tn;
    tn = ReferedTable();
                        trl.add(tn);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[17] = jj_gen;
        break label_5;
      }
      jj_consume_token(COMMA);
      tn = ReferedTable();
                                    trl.add(tn);
    }
    {if (true) return trl;}
    throw new Error("Missing return statement in function");
  }

  final public String ReferedTable() throws ParseException {
  String tn1; String tn2;
    if (jj_2_6(2147483647)) {
      tn1 = TableName();
      jj_consume_token(AS);
      tn2 = TableName();
                                               {if (true) return tn1 + "@as@" + tn2;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:
        tn1 = TableName();
                      {if (true) return tn1;}
        break;
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public BooleanValueExpression WhereClause() throws ParseException {
  BooleanValueExpression bve;
    jj_consume_token(WHERE);
    bve = BooleanValueExpression();
                                             {if (true) return bve;}
    throw new Error("Missing return statement in function");
  }

  final public BooleanValueExpression BooleanValueExpression() throws ParseException {
  BooleanTerm bt; BooleanValueExpression bve = new BooleanValueExpression();
    bt = BooleanTerm();
                       bve.bts.add(bt);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_6;
      }
      jj_consume_token(OR);
      bt = BooleanTerm();
                                bve.bts.add(bt);
    }
    {if (true) return bve;}
    throw new Error("Missing return statement in function");
  }

  final public BooleanTerm BooleanTerm() throws ParseException {
  BooleanFactor bf; BooleanTerm bt = new BooleanTerm();
    bf = BooleanFactor();
                         bt.bfs.add(bf);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_7;
      }
      jj_consume_token(AND);
      bf = BooleanFactor();
                                   bt.bfs.add(bf);
    }
    {if (true) return bt;}
    throw new Error("Missing return statement in function");
  }

  final public BooleanFactor BooleanFactor() throws ParseException {
  BooleanFactor bf = new BooleanFactor(null, null); BooleanTest bt;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT_PAREN:
    case DIGIT:
    case ALPHABET:
    case LEGAL_IDENTIFIER:
    case INT_VALUE:
    case DATE_VALUE:
    case CHAR_STRING:
      bt = BooleanTest();
                       bf.bt = bt; {if (true) return bf;}
      break;
    case NOT:
      jj_consume_token(NOT);
      bt = BooleanTest();
                               bf.not = "not"; bf.bt = bt; {if (true) return bf;}
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public BooleanTest BooleanTest() throws ParseException {
  BooleanTest bt = new BooleanTest(null, null); Predicate p; BooleanValueExpression bve;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIGIT:
    case ALPHABET:
    case LEGAL_IDENTIFIER:
    case INT_VALUE:
    case DATE_VALUE:
    case CHAR_STRING:
      p = Predicate();
                    bt.p = p; {if (true) return bt;}
      break;
    case LEFT_PAREN:
      bve = ParentehsizedBooleanExpression();
                                           bt.bve = bve; {if (true) return bt;}
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public BooleanValueExpression ParentehsizedBooleanExpression() throws ParseException {
  BooleanValueExpression bve;
    jj_consume_token(LEFT_PAREN);
    bve = BooleanValueExpression();
    jj_consume_token(RIGHT_PAREN);
                                                                  {if (true) return bve;}
    throw new Error("Missing return statement in function");
  }

  final public Predicate Predicate() throws ParseException {
  Predicate p = new Predicate(null, null); ComparisonPredicate cp; NullPredicate np;
    if (jj_2_7(2147483647)) {
      cp = ComparisonPredicate();
                               p.cp = cp; {if (true) return p;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:
        np = NullPredicate();
                         p.np = np; {if (true) return p;}
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public ComparisonPredicate ComparisonPredicate() throws ParseException {
  CompOperand co1; CompOperand co2; Token compOp; ComparisonPredicate cp = new ComparisonPredicate(null, null, null);
    co1 = CompOperand();
    compOp = jj_consume_token(COMP_OP);
    co2 = CompOperand();
                                                                 cp.co1 = co1; cp.co2 = co2; cp.compOp = compOp.image; {if (true) return cp;}
    throw new Error("Missing return statement in function");
  }

  final public CompOperand CompOperand() throws ParseException {
  CompOperand co = new CompOperand(null, null, null); String s;
    if (jj_2_8(2147483647)) {
      s = CompOperandAux();
                         co.compOperandAux = s; {if (true) return co;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:
        s = ColumnName();
                     co.columnName = s; {if (true) return co;}
        break;
      case DIGIT:
      case INT_VALUE:
      case DATE_VALUE:
      case CHAR_STRING:
        s = ComparableValue();
                          co.comparableValue = s; {if (true) return co;}
        break;
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public String CompOperandAux() throws ParseException {
  String tblName; String colName;
    tblName = TableName();
    jj_consume_token(PERIOD);
    colName = ColumnName();
    {if (true) return tblName + "." + colName;}
    throw new Error("Missing return statement in function");
  }

/* example
num:+13
num:-13
date:2017-12-12
str:cybl
*/
  final public String ComparableValue() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DATE_VALUE:
      t = jj_consume_token(DATE_VALUE);
                       {if (true) return "date:" + t.image;}
      break;
    case INT_VALUE:
      t = jj_consume_token(INT_VALUE);
                      {if (true) return "num:" + t.image;}
      break;
    case DIGIT:
      t = jj_consume_token(DIGIT);
                  {if (true) return "num:" + t.image;}
      break;
    case CHAR_STRING:
      t = jj_consume_token(CHAR_STRING);
                        {if (true) return "str:" + t.image;}
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public NullPredicate NullPredicate() throws ParseException {
  NullPredicate np = new NullPredicate(null, null, null); String npa; String nop; String colName;
    if (jj_2_9(2147483647)) {
      npa = NullPredicateAux();
      nop = NullOperation();
                                                   np.nullPredicateAux = npa; np.nullOperation = nop; {if (true) return np;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALPHABET:
      case LEGAL_IDENTIFIER:
        colName = ColumnName();
        nop = NullOperation();
                                                 np.columnName = colName; np.nullOperation = nop; {if (true) return np;}
        break;
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public String NullPredicateAux() throws ParseException {
 String tblName; String colName;
    tblName = TableName();
    jj_consume_token(PERIOD);
    colName = ColumnName();
                                                            {if (true) return tblName + "." + colName;}
    throw new Error("Missing return statement in function");
  }

  final public String NullOperation() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IS_NULL:
      jj_consume_token(IS_NULL);
                {if (true) return "is null";}
      break;
    case IS_NOT_NULL:
      jj_consume_token(IS_NOT_NULL);
                    {if (true) return "is not null";}
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// helper function like split
  final public ArrayList<String> split(String s, String token) throws ParseException {
        ArrayList<String> result = new ArrayList<String>();
    StringTokenizer st = new StringTokenizer(s, token);

        while(st.hasMoreTokens()) {
          result.add(st.nextToken());
        }

        {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

// return column name list or column type list depending on nt("name", "type")
  final public ArrayList<String> getColumns(String colDef, String nt) throws ParseException {
    StringTokenizer st = new StringTokenizer(colDef, delim);
        ArrayList<String> results = new ArrayList<String>();
        while (st.hasMoreTokens()) {
      String colName = st.nextToken();
      String colType = st.nextToken();

          if(nt.equals("name")) {
                results.add(colName);
          } else if(nt.equals("type")) {
                results.add(colType);
          } else {
                {if (true) return null;}
          }
    }

    {if (true) return results;}
    throw new Error("Missing return statement in function");
  }

// return exist column's type from input column name
// ex) inputColumnName : "student"
// ex) existColumnType : "int*not null"
// ex) return existColumnType
  final public String findExisttypeFromInput(String inputColumnName, ArrayList<String> existColumnNames, ArrayList<String> existColumnTypes) throws ParseException {
        for(int i=0; i<existColumnNames.size(); i++) {
          if(existColumnNames.get(i).equals(inputColumnName)) {
                {if (true) return existColumnTypes.get(i);}
          }
        }
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/*
String findExistnameFromInput(String inputColumnName, ArrayList<String> existColumnNames) :
{}
{
  {
	for(int i=0; i<existColumnNames.size(); i++) {
	  if(existColumnNames.get(i).equals(inputColumnName)) {
		return existColumnNames.get(i);
	  }
	}
	return null;
  }
}
*/

// check if inputValue's type and column's type same
// ex) colType : int*not null;
// ex) inputValue : num:13, char:'jw'
  final public boolean isTypeSame(String colType, String inputValue) throws ParseException {
        String existRealType = split(colType, "*").get(0);
        if(inputValue.equals("null")) { {if (true) return true;} }
        else if((existRealType.contains("int") && !inputValue.substring(0,3).equals("num")) ||
                 (existRealType.contains("char") && !inputValue.substring(0,3).equals("str")) ||
                 (existRealType.contains("date") && !inputValue.substring(0,4).equals("date"))) {
                 {if (true) return false;}
        }
        else { {if (true) return true;} }
    throw new Error("Missing return statement in function");
  }

  final public boolean CheckInsertTypeMismatchError(String tblName, String colAndSrc) throws ParseException {
    String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
    ArrayList<String> existColumnNames = getColumns(colDef, "name");
    ArrayList<String> existColumnTypes = getColumns(colDef, "type");

    if(existColumnNames.size() != existColumnTypes.size()) {
                {if (true) return true;}
    }

    String[] temp_strs = colAndSrc.split("/");
        // no input column names
    if(temp_strs.length == 1) {
      //System.out.println("colAndSrc: " + colAndSrc.substring(1));
      String[] inputValues = colAndSrc.substring(1).split("\u005c\u005c|");
      //System.out.println("input values start------------------");
      //System.out.println(inputValues[0]);
      //System.out.println("input values end--------------------");
      //System.out.println("existColumnNames size: " + existColumnNames.size());
      if(existColumnNames.size() != inputValues.length) {
                // case : no input column names and (# of inputValues != # of existColumnNames)
                //System.out.println("jaewan, 111");
                {if (true) return true;}
      }
      for(int i=0; i<existColumnTypes.size(); i++) {
          // case : same #of columnTypes and values , but existColumnTypes and inputValuetypes are different
            if(!isTypeSame(existColumnTypes.get(i), inputValues[i])) {
                                //System.out.println("i: " + i);
                       //System.out.println("extistRealType: " + existRealType);
                       //System.out.println("inputValues[i]: " + inputValues[i].substring(0,4));
                  {if (true) return true;}
            }
          }
          {if (true) return false;}
    }

        //exist explicit column names
        else {
          String[] _inputColumnNames = temp_strs[0].substring(1).split("\u005c\u005c|");
          String[] _inputValues = temp_strs[1].substring(1).split("\u005c\u005c|");
      ArrayList<String> inputColumnNames = new ArrayList<String>(Arrays.asList(_inputColumnNames));
      ArrayList<String> inputValues = new ArrayList<String>(Arrays.asList(_inputValues));
          Set<String> inputColumnNamesSet = new HashSet<String>(inputColumnNames);

          if(inputColumnNamesSet.size() < inputColumnNames.size()){
            // duplicate exists in values column names
            //System.out.println("jaewan, 3333");
            {if (true) return true;}
          }
          // input columns > existing columns
          if(inputColumnNames.size() > existColumnTypes.size()) {
                //System.out.println("jaewan, 4444");
                {if (true) return true;}
          }
          // input columns != input values
          if(_inputColumnNames.length != _inputValues.length) {
            //System.out.println("jaewan, 5555");
                {if (true) return true;}
          }

          for(int i=0; i<inputColumnNames.size(); i++) {
                String colType = findExisttypeFromInput(inputColumnNames.get(i), existColumnNames, existColumnTypes);
                // no column name exists such that input column name
                if(colType == null) { {if (true) return true;} }
                // exist column type and input value type mismatch
                if(!isTypeSame(colType, inputValues.get(i))) {
                     {if (true) return true;}
                }
          }// for close

          {if (true) return false;}
        } // else close

    throw new Error("Missing return statement in function");
  }

  final public String CheckInsertColumnNonNullableError(String tblName, String colAndSrc) throws ParseException {
        String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
    ArrayList<String> existColumnNames = getColumns(colDef, "name");
    ArrayList<String> existColumnTypes = getColumns(colDef, "type");

    if(existColumnNames.size() != existColumnTypes.size()) {
                //System.out.println("jaewan, #of col names and #of col type diff error");
                {if (true) return "jw";}
    }

    String[] temp_strs = colAndSrc.split("/");
        // no input column names
    if(temp_strs.length == 1) {
      String[] _inputValues = colAndSrc.substring(1).split("\u005c\u005c|");
      ArrayList<String> inputValues = new ArrayList<String>(Arrays.asList(_inputValues));

      for(int i=0; i<existColumnTypes.size(); i++) {
        boolean notNull;
                int existColumnTypeSize = split(existColumnTypes.get(i), "*").size();
                // ex) int*not null(size == 2) or int(size == 1)
                if(existColumnTypeSize == 1) { notNull = false; }
                else { notNull = true; }

                if(inputValues.get(i).equals("null") && notNull) {
                  {if (true) return existColumnNames.get(i);}
                }
      }
    } // if end
    else {
      String[] _inputColumnNames = temp_strs[0].substring(1).split("\u005c\u005c|");
          String[] _inputValues = temp_strs[1].substring(1).split("\u005c\u005c|");
      ArrayList<String> inputColumnNames = new ArrayList<String>(Arrays.asList(_inputColumnNames));
      ArrayList<String> inputValues = new ArrayList<String>(Arrays.asList(_inputValues));

      for(int i=0; i<inputColumnNames.size(); i++) {
                String colType = findExisttypeFromInput(inputColumnNames.get(i), existColumnNames, existColumnTypes);
                boolean notNull;
        int colTypeSize = split(colType, "*").size();
        if(colTypeSize == 1) { notNull = false; }
        else { notNull = true; }

        if(inputValues.get(i).equals("null") && notNull) {
          {if (true) return inputValues.get(i);}
        }
      }
    } // else end

    {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public String CheckInsertColumnExistenceError(String tblName, String colAndSrc) throws ParseException {
    String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
    ArrayList<String> existColumnNames = getColumns(colDef, "name");
    ArrayList<String> existColumnTypes = getColumns(colDef, "type");

        String[] temp_strs = colAndSrc.split("/");
        // no input column names
    if(temp_strs.length == 1) { {if (true) return null;} }
    else {
      String[] _inputColumnNames = temp_strs[0].substring(1).split("\u005c\u005c|");
      ArrayList<String> inputColumnNames = new ArrayList<String>(Arrays.asList(_inputColumnNames));
      for(int i=0; i<inputColumnNames.size(); i++) {
                if(!existColumnNames.contains(inputColumnNames.get(i))) {
                  {if (true) return inputColumnNames.get(i);}
                }
      }
    } // else close
    {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

// change colAndSrc to complete form, and column orders are same to tblName
  final public String changeColAndSrc(String tblName, String colAndSrc) throws ParseException {
    String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
    ArrayList<String> existColumnNames = getColumns(colDef, "name");
    ArrayList<String> existColumnTypes = getColumns(colDef, "type");

    String[] temp_strs = colAndSrc.split("/");
    // no exist explicit column
    if(temp_strs.length == 1) {
      String result = "";
      for(int i=0; i<existColumnNames.size(); i++) {
        result = result + "|" + existColumnNames.get(i);
      }
      {if (true) return result + "/" + colAndSrc;}
    }
    // exist explicit column
    else {
      String[] _inputColumnNames = temp_strs[0].substring(1).split("\u005c\u005c|");
          String[] _inputValues = temp_strs[1].substring(1).split("\u005c\u005c|");
      ArrayList<String> inputColumnNames = new ArrayList<String>(Arrays.asList(_inputColumnNames));
      ArrayList<String> inputValues = new ArrayList<String>(Arrays.asList(_inputValues));
      String resultColName = "";
      String resultValue = "";
      for(int i=0; i<existColumnNames.size(); i++) {
                resultColName = resultColName + "|" + existColumnNames.get(i);
        boolean matchFound = false;
        for(int j=0; j<inputColumnNames.size(); j++) {
          String existColName = existColumnNames.get(i);
          String inputColName = inputColumnNames.get(j);
          if(existColName.equals(inputColName)) {
            matchFound = true;
            resultValue = resultValue + "|" + inputValues.get(j);
          }
        } // inner for close

        if(!matchFound) { resultValue = resultValue + "|" + "null"; }
      } // outer for close

      {if (true) return resultColName + "/" + resultValue;}
    } // else close

    throw new Error("Missing return statement in function");
  }

// find pk Indices of tblName
  final public ArrayList<Integer> findPkIndex(String tblName) throws ParseException {
    String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
    ArrayList<String> columnNames = getColumns(colDef, "name");
    ArrayList<String> pkNames = split(myDB.getDB(tblName + " @primary key").elementAt(0), "|");
    ArrayList<Integer> pkIndices = new ArrayList<Integer>();
    for(int i=0; i<columnNames.size(); i++) {
      for(int j=0; j<pkNames.size(); j++) {
        if(columnNames.get(i).equals(pkNames.get(j))) {
          pkIndices.add(i);
          break;
        }
      }
    }

    {if (true) return pkIndices;}
    throw new Error("Missing return statement in function");
  }

  final public boolean CheckInsertDuplicatePrimaryKeyError(String tblName, String changedColAndSrc) throws ParseException {
    /* not null and unique on primary key */
        Vector<String> records = myDB.getDB(tblName + " @records");
        ArrayList<Integer> pkIndices = findPkIndex(tblName);
        ArrayList<String> inputValues = split(changedColAndSrc.split("/")[1], "|");

        // check not null on primary key column 
        for(int i=0; i<pkIndices.size(); i++) {
          if(inputValues.get(pkIndices.get(i)).equals("null")) {
            {if (true) return true;}
          }
        }
        // check uniqueness on primary key
        for(int i=0; i<records.size(); i++) {
          boolean isUnique = false;
          ArrayList<String> record = split(records.get(i), "|");
          for(int j=0; j<pkIndices.size(); j++) {
            // if just one column is different on pk columns, unique
            int pkIndex = pkIndices.get(j);
            if(!record.get(pkIndex).equals(inputValues.get(pkIndex))) {
              isUnique = true;
              break;
            }
          } // inner for close

          if(!isUnique) {
            //System.out.println("reason record: " + records.get(i));
            {if (true) return true;}
          }
        }

        // yeah, not null and unique
        {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

//find indices of table's column from 'my' column names
//assume 'my' column names all exist in table
  final public ArrayList<Integer> findColumnIndices(String tblName, ArrayList<String> colNames) throws ParseException {
    String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
    ArrayList<String> existColumnNames = getColumns(colDef, "name");
    ArrayList<Integer> indices = new ArrayList<Integer>();
    for(int i=0; i<colNames.size(); i++) {
      for(int j=0; j<existColumnNames.size(); j++) {
        if(colNames.get(i).equals(existColumnNames.get(j))) {
          indices.add(j);
          break;
        }
      }
    }

    {if (true) return indices;}
    throw new Error("Missing return statement in function");
  }

  final public boolean CheckInsertReferentialIntegrityError(String tblName, String changedColAndSrc) throws ParseException {
    // find fk column names from my table
    Vector<String> fkcs = myDB.getDB(tblName + " @foreign key");
    ArrayList<String> inputColumnNames = split(changedColAndSrc.split("/")[0], "|");
    ArrayList<String> inputValues = split(changedColAndSrc.split("/")[1], "|");

    for(int i=0; i<fkcs.size(); i++) {
      String fkc = fkcs.elementAt(i);
      String _fkColNames = split(fkc, "@").get(0);
      ArrayList<String> fkColNames = split(_fkColNames, "|");

      ArrayList<String> temp_list = split(split(fkc, "&").get(1), "|");
      String refTblName = temp_list.get(0);
      ArrayList<String> refColNames = new ArrayList<String>();
      for(int j=1; j<temp_list.size(); j++) {
        refColNames.add(temp_list.get(j));
      }

      ArrayList<String> existCheckColNames = new ArrayList<String>();
      ArrayList<String> existCheckValues = new ArrayList<String>();

      // extract fk columns and values from input
      for(int j=0; j<inputColumnNames.size(); j++) {
        for(int k=0; k<fkColNames.size(); k++) {
          if(fkColNames.get(k).equals(inputColumnNames.get(j))) {
            existCheckColNames.add(refColNames.get(k));
            existCheckValues.add(inputValues.get(j));
          } // if end
        } // kdx end
      } //jdx end

      if(!isRecordExistForeignKey(refTblName, existCheckColNames, existCheckValues)) {
        {if (true) return true;}
      }
    }// idx end

    {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

  final public boolean isRecordExistForeignKey(String tblName, ArrayList<String> colNames, ArrayList<String> values) throws ParseException {
    Vector<String> records = myDB.getDB(tblName + " @records");
    // tblName : enemy, colName : my colNames
    ArrayList<Integer> colIndices = findColumnIndices(tblName, colNames);

        if(colIndices.size() != values.size()) {
          //System.out.println("jaewan, findColumnIndices error");
        }

    for(int i=0; i<records.size(); i++) {
      ArrayList<String> record = split(records.get(i), "|");
      int matchCount = 0;
      for(int j=0; j<values.size(); j++) {
        if(values.get(j).equals("null")) {
          matchCount++;
          break;
        }
        int existColIndex = colIndices.get(j);

        if(values.get(j).equals(record.get(existColIndex))) {
          matchCount++;
          break;
        }
      } // inner for close

      if(matchCount == values.size()) {
        {if (true) return true;}
      }

    } // outer for close


    {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

// when insert, truncate values that is char type
  final public String truncate(String tblName, String changedColAndSrc) throws ParseException {
    //String findExisttypeFromInput(String inputColumnName, ArrayList<String> existColumnNames, ArrayList<String> existColumnTypes)
    String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
    ArrayList<String> existColumnNames = getColumns(colDef, "name");
    ArrayList<String> existColumnTypes = getColumns(colDef, "type");

        String result = "";
        String col = changedColAndSrc.split("/")[0];
        String src = changedColAndSrc.split("/")[1];
        String resultSrc = "";
        ArrayList<String> inputColumnNames = split(col, " |");
        ArrayList<String> inputValues = split(src, "|");
        for(int i=0; i<inputValues.size(); i++) {
          if(inputValues.get(i).equals("null")) {
            resultSrc = resultSrc + "|" + "null";
            continue;
          }
          String valueType = inputValues.get(i).split(":")[0];
          String realValue = inputValues.get(i).split(":")[1];
          String tempResult = "";
          String existColType = findExisttypeFromInput(inputColumnNames.get(i), existColumnNames, existColumnTypes);
          String existRealType = split(existColType, "*").get(0);
          if(valueType.equals("str")) {
            // existRealType = char(d1d2d3...dn)
            int charLengthLimit = Integer.parseInt(existRealType.substring(5, existRealType.length()-1));
            // should consider ''
            if(charLengthLimit < realValue.length()-2) {
              String realString = realValue.substring(1, realValue.length()-1);
              tempResult = valueType + ":" + "'" + realString.substring(0, charLengthLimit) + "'";
              resultSrc = resultSrc + "|" + tempResult;
            } else {
              tempResult = valueType + ":" + realValue;
              resultSrc = resultSrc + "|" + tempResult;
            }
          }
          else {
            resultSrc = resultSrc + "|" + inputValues.get(i);
          }
        }

        {if (true) return resultSrc;}
    throw new Error("Missing return statement in function");
  }

  final public int InsertQuery() throws ParseException {
  String tblName;
  String colAndSrc;
  String colName;
  String changedColAndSrc = "";
  String finalInputString = "";
    tmpForKey = "";
    jj_consume_token(INSERT_INTO);
    tblName = TableName();
    if (CheckNoSuchTable(tblName))
    {
      NoSuchTable();
    }
    colAndSrc = InsertColumnsAndSource();
    if ((colName = CheckInsertColumnExistenceError(tblName, colAndSrc)) != null) {
      System.out.println("Insertion has failed: '" + colName + "' does not exist");
      handleDBError(parser);
    }
    else if (CheckInsertTypeMismatchError(tblName, colAndSrc)) {
      System.out.println("Insertion has failed: Types are not matched");
      handleDBError(parser);
    }

        changedColAndSrc = changeColAndSrc(tblName, colAndSrc);
    if ((colName = CheckInsertColumnNonNullableError(tblName, colAndSrc)) != null) {
      System.out.println("Insertion has failed: '" + colName + "' is not nullable");
      handleDBError(parser);
    }
    else {

      if(CheckInsertDuplicatePrimaryKeyError(tblName, changedColAndSrc)) {
        System.out.println("Insertion has failed: Primary key duplication");
        handleDBError(parser);
      }
      else if(CheckInsertReferentialIntegrityError(tblName, changedColAndSrc)) {
        System.out.println("Insertion has failed: Referential integrity violation");
        handleDBError(parser);
      }
    }

    finalInputString = truncate(tblName, changedColAndSrc);
    myDB.putDB(tblName + " @records", finalInputString);
    {if (true) return 5;}
    throw new Error("Missing return statement in function");
  }

  final public String InsertColumnsAndSource() throws ParseException {
 String valueList = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT_PAREN:
      ColumnNameList(false);
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    valueList = ValueList();
    if(tmpForKey.equals("")) { {if (true) return valueList;} }
    else { {if (true) return tmpForKey + '/' + valueList;} }
    throw new Error("Missing return statement in function");
  }

  final public String ValueList() throws ParseException {
  String valueList = "";
  String value = "";
    jj_consume_token(VALUES);
    jj_consume_token(LEFT_PAREN);
    value = Value();
                                              valueList += delim + value;
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[29] = jj_gen;
        break label_8;
      }
      jj_consume_token(COMMA);
      value = Value();
                                valueList += delim + value;
    }
    jj_consume_token(RIGHT_PAREN);
                    {if (true) return valueList;}
    throw new Error("Missing return statement in function");
  }

  final public String Value() throws ParseException {
  String compValue;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NULL:
      jj_consume_token(NULL);
             {if (true) return "null";}
      break;
    case DIGIT:
    case INT_VALUE:
    case DATE_VALUE:
    case CHAR_STRING:
      compValue = ComparableValue();
                                  {if (true) return compValue;}
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

// extract all comparison predicates from bve
// return ArrayList<ComparisonPredicate> comparsionPredicates in bve
// used in where incomparable error check
  final public ArrayList<ComparisonPredicate> extractComparisonPredicatesFromBVE(BooleanValueExpression bve) throws ParseException {
        ArrayList<ComparisonPredicate> comparisonPredicates = new ArrayList<ComparisonPredicate>();
        if(bve == null) {if (true) return comparisonPredicates;}

        for(BooleanTerm bterm : bve.bts) {
          for(BooleanFactor bfactor : bterm.bfs) {
            if(bfactor.bt.p != null && bfactor.bt.p.cp != null) { comparisonPredicates.add(bfactor.bt.p.cp); }
          }
        }

        {if (true) return comparisonPredicates;}
    throw new Error("Missing return statement in function");
  }

// extract all predicates from bve
// return ArrayList<Predicate> predicates in bve
// used in where table not specified error check
  final public ArrayList<Predicate> extractPredicatesFromBVE(BooleanValueExpression bve) throws ParseException {
        ArrayList<Predicate> predicates = new ArrayList<Predicate>();
        if(bve == null) {if (true) return predicates;}

        for(BooleanTerm bterm : bve.bts) {
          for(BooleanFactor bfactor : bterm.bfs) {
            if(bfactor.bt.p != null) { predicates.add(bfactor.bt.p); }
          }
        }

        {if (true) return predicates;}
    throw new Error("Missing return statement in function");
  }

// tblName should contain every possible table names
// ex) from stu as s, ins as i
// then tblNames = { "stu", "s", "ins", "i" }
  final public boolean CheckWhereTableNotSpecifiedError(ArrayList<String> tblNames, BooleanValueExpression bve) throws ParseException {
        ArrayList<Predicate> predicates = extractPredicatesFromBVE(bve);

        for(Predicate p : predicates) {
          if(p.cp != null) {
            CompOperand co1 = p.cp.co1; CompOperand co2 = p.cp.co2;
            if(co1.compOperandAux != null) {
              String tblName = split(co1.compOperandAux, ".").get(0);
              if(!tblNames.contains(tblName)) { {if (true) return true;} }
            }
            if(co2.compOperandAux != null) {
              String tblName = split(co2.compOperandAux, ".").get(0);
              if(!tblNames.contains(tblName)) { {if (true) return true;} }
            }
          } else if(p.np != null) {
            if(p.np.nullPredicateAux == null) { {if (true) return false;} }
                String tblName = split(p.np.nullPredicateAux, ".").get(0);
                if(!tblNames.contains(tblName)) { {if (true) return true;} }
          }
          else {
                //System.out.println("in CheckWhereTableNotSpecifiedError, both cp and np null error");
                {if (true) return true;}
          }
        }

        {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

// find number of matches of (column name aux or column name) from table name list
// used in where column not exist , where column ambiguous reference
// if match cnt == 0 : column not exist
// if match cnt > 1 : column ambiguous reference
// when both columnNameAux and columnName not null error, return 0
  final public int findColumnMatchCount(ArrayList<String> tblNames, String columnNameAux, String columnName) throws ParseException {
        if(columnNameAux != null) {
          int refCnt = 0;
          String inputTblName = split(columnNameAux, ".").get(0);
          String inputColName = split(columnNameAux, ".").get(1);
          String colDef = myDB.getDB(inputTblName + " @column definition").elementAt(0);
          ArrayList<String> existColumnNames = getColumns(colDef, "name");
          for(String tblName : tblNames) {
            if(tblName.equals(inputTblName) && existColumnNames.contains(inputColName)) { refCnt++; }
          }
          {if (true) return refCnt;}

        } else if(columnName != null) {
          String inputColName = columnName;
          int colRefCnt = 0;
          for(String tblName : tblNames) {
            String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
            ArrayList<String> existColumnNames = getColumns(colDef, "name");
            if(existColumnNames.contains(inputColName)) { colRefCnt++; }
          }
          {if (true) return colRefCnt;}
        } else {
          // case : contant
          {if (true) return 1;}
        }
    throw new Error("Missing return statement in function");
  }

  final public boolean CheckWhereColumnNotExistError(ArrayList<String> tblNames, BooleanValueExpression bve) throws ParseException {
        ArrayList<Predicate> predicates = extractPredicatesFromBVE(bve);
        for(Predicate p : predicates) {
          if(p.cp != null) {
            CompOperand co1 = p.cp.co1; CompOperand co2 = p.cp.co2;
            int co1RefCnt = findColumnMatchCount(tblNames, co1.compOperandAux, co1.columnName);
            if(co1RefCnt == 0) { {if (true) return true;} }
            int co2RefCnt = findColumnMatchCount(tblNames, co2.compOperandAux, co2.columnName);
            if(co2RefCnt == 0) { {if (true) return true;} }

          } else if(p.np != null) {
            int npRefCnt = findColumnMatchCount(tblNames, p.np.nullPredicateAux, p.np.columnName);
            if(npRefCnt == 0) { {if (true) return true;} }
          } else {
                //System.out.println("in check where column not exist error, both predicate and null predicate not null error");
            {if (true) return true;}
          }
        }

        {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

  final public boolean CheckWhereAmbiguousReferenceError(ArrayList<String> tblNames, BooleanValueExpression bve) throws ParseException {
    ArrayList<Predicate> predicates = extractPredicatesFromBVE(bve);
        for(Predicate p : predicates) {
          if(p.cp != null) {
            CompOperand co1 = p.cp.co1; CompOperand co2 = p.cp.co2;
            int co1RefCnt = findColumnMatchCount(tblNames, co1.compOperandAux, co1.columnName);
            if(co1RefCnt > 1) { {if (true) return true;} }
            int co2RefCnt = findColumnMatchCount(tblNames, co2.compOperandAux, co2.columnName);
            if(co2RefCnt > 1) { {if (true) return true;} }

          } else if(p.np != null) {
            int npRefCnt = findColumnMatchCount(tblNames, p.np.nullPredicateAux, p.np.columnName);
            if(npRefCnt > 1) { {if (true) return true;} }
          } else {
                //System.out.println("in check where ambiguous reference error, both predicate and null predicate not null error");
            {if (true) return true;}
          }
        }

        {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

// return real type of CompOperand
// ex) return "int", "char", "date", "null"
// tblNames : when delete, delete query's table name
// tblNames : when select, from's table names
  final public String getTypeFromCompOperand(ArrayList<String> tblNames, CompOperand co) throws ParseException {
    String coType;
    if(co.compOperandAux != null) {
      String tblName = split(co.compOperandAux, ".").get(0);
      String colName = split(co.compOperandAux, ".").get(1);
      String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
      ArrayList<String> existColumnNames = getColumns(colDef, "name");
      ArrayList<String> existColumnTypes = getColumns(colDef, "type");
      String colType = findExisttypeFromInput(colName, existColumnNames, existColumnTypes);

      coType = split(colType, "*").get(0);
    }
    else if(co.columnName != null) {
      String colName = co.columnName;

      String colType = "";
      for(String tblName : tblNames) {
        String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
        ArrayList<String> existColumnNames = getColumns(colDef, "name");
        ArrayList<String> existColumnTypes = getColumns(colDef, "type");
        colType = findExisttypeFromInput(colName, existColumnNames, existColumnTypes);
        if(colType != null) { break; }
      }

      coType = split(colType, "*").get(0);
    }
    else if(co.comparableValue != null) {
      String valueType = split(co.comparableValue, ":").get(0);
      coType = valueType;
    }
    else { System.out.println("CompOperand all null error"); coType = ""; }

    if(coType.contains("int")) { {if (true) return "int";} }
    else if(coType.contains("char")) { {if (true) return "char";} }
    else if(coType.contains("date")) { {if (true) return "date";} }
    else if(coType.contains("str")) { {if (true) return "char";} }
    else if(coType.contains("num")) { {if (true) return "int";} }
    // error case
    else { System.out.println("getTypeFromCompOperand error, type is strange"); {if (true) return null;}}
    throw new Error("Missing return statement in function");
  }

  final public boolean CheckWhereIncomparableError(ArrayList<String> tblNames, BooleanValueExpression bve) throws ParseException {
    ArrayList<ComparisonPredicate> cps = extractComparisonPredicatesFromBVE(bve);
    for(ComparisonPredicate cp : cps) {
      String co1Type = getTypeFromCompOperand(tblNames, cp.co1);
      String co2Type = getTypeFromCompOperand(tblNames, cp.co2);
      if(co1Type.equals(co2Type)) { {if (true) return false;} }
      else { {if (true) return true;} }
    }
    {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

  final public String evalRecordWithPredicate(ArrayList<String> values, String tblName, Predicate p) throws ParseException {
    String colDef = myDB.getDB(tblName + " @column definition").elementAt(0);
    ArrayList<String> columnNames = getColumns(colDef, "name");
    // setting value1
    if(p.cp != null) {
      CompOperand co1 = p.cp.co1;
      CompOperand co2 = p.cp.co2;
      String compOp = p.cp.compOp;
      String value1 = "";
      String value2 = "";
      if(co1.compOperandAux != null) {
        String colName = split(co1.compOperandAux, ".").get(1);
        for(int i=0; i<columnNames.size(); i++) {
          if(columnNames.get(i).equals(colName)) {
            value1 = values.get(i);
            break;
          }
        }
      } else if(co1.columnName != null) {
        String colName = co1.columnName;
        for(int i=0; i<columnNames.size(); i++) {
          if(columnNames.get(i).equals(colName)) {
            value1 = values.get(i);
            break;
          }
        }
      }
      else {
        value1 = p.cp.co1.comparableValue;
      }
      // setting value2
      if(co2.compOperandAux != null) {
        String colName = split(co2.compOperandAux, ".").get(1);
        for(int i=0; i<columnNames.size(); i++) {
          if(columnNames.get(i).equals(colName)) {
            value2 = values.get(i);
            break;
          }
        }
      } else if(co2.columnName != null) {
        String colName = co2.columnName;
        for(int i=0; i<columnNames.size(); i++) {
          if(columnNames.get(i).equals(colName)) {
            value2 = values.get(i);
            break;
          }
        }
      }
      else {
        value2 = p.cp.co2.comparableValue;
      }

      if(value1.equals("") || value2.equals("")) { System.out.println("evalRecords, cp value1 or value2 not got error");}

      // compare value1 , value2
      if(value1.equals("null") || value2.equals("null")) {
                // unknown 
        {if (true) return "unknown";}
      } else {
        String valueType = split(value1, ":").get(0);
        String value1Value = split(value1, ":").get(1);
        String value2Value = split(value2, ":").get(1);

        if(valueType.equals("num")) {
          int _value1 = Integer.parseInt(value1Value);
          int _value2 = Integer.parseInt(value2Value);
          if(compOp.equals("<")) { {if (true) return _value1 < _value2 ? "true" : "false";} }
          else if(compOp.equals(">")) { {if (true) return _value1 > _value2 ? "true" : "false";} }
          else if(compOp.equals("<=")) { {if (true) return _value1 <= _value2 ? "true" : "false";} }
          else if(compOp.equals(">=")) { {if (true) return _value1 >= _value2 ? "true" : "false";} }
          else if(compOp.equals("!=")) { {if (true) return _value1 != _value2 ? "true" : "false";} }
          else { {if (true) return _value1 == _value2 ? "true" : "false";} }
        }

        else if(valueType.equals("str")) {
          // trim ''
          String _value1 = value1Value.substring(1, value1Value.length());
          String _value2 = value2Value.substring(1, value2Value.length());

          int compResult = _value1.compareTo(_value2);
          if(compOp.equals("<")) { {if (true) return compResult < 0 ? "true" : "false";}}
          else if(compOp.equals(">")) { {if (true) return compResult > 0 ? "true" : "false";} }
          else if(compOp.equals("<=")) { {if (true) return compResult <= 0 ? "true" : "false";}}
          else if(compOp.equals(">=")) { {if (true) return compResult >= 0 ? "true" : "false";}}
          else if(compOp.equals("!=")) { {if (true) return compResult != 0 ? "true" : "false";}}
          else { {if (true) return compResult == 0 ? "true" : "false";}}
        }

        else if(valueType.equals("date")) {
          int compResult = value1.compareTo(value2);
          if(compOp.equals("<")) { {if (true) return compResult < 0 ? "true" : "false";}}
          else if(compOp.equals(">")) { {if (true) return compResult > 0 ? "true" : "false";} }
          else if(compOp.equals("<=")) { {if (true) return compResult <= 0 ? "true" : "false";}}
          else if(compOp.equals(">=")) { {if (true) return compResult >= 0 ? "true" : "false";}}
          else if(compOp.equals("!=")) { {if (true) return compResult != 0 ? "true" : "false";}}
          else { {if (true) return compResult == 0 ? "true" : "false";}}
        }
        // value type error case
        else {
          System.out.println("evalRecords, comparable value type error");
          {if (true) return "false";}
        }
      }
    } else if(p.np != null) {
      String colName;
      String value = "";
      if(p.np.nullPredicateAux != null) { colName = split(p.np.nullPredicateAux, ".").get(1); }
      else if(p.np.columnName != null) { colName = p.np.columnName; }
      else { System.out.println("evalRecords, null predicate has no both nullPredicateAux and columnName"); {if (true) return "false";} }
      // setting value
      for(int i=0; i<columnNames.size(); i++) {
        if(columnNames.get(i).equals(colName)) {
          value = values.get(i);
          break;
        }
      }

      if(value.equals("")) { System.out.println("evalRecords, np value not got error"); {if (true) return "false";} }

      // is null
      if(p.np.nullOperation.equals("is null")) {
        {if (true) return value.equals("null") ? "true" : "false";}
      }
      // is not null
      else {
                {if (true) return !value.equals("null") ? "true" : "false";}
      }
    } else {
      System.out.println("evalRecordWithPredicate, both cp and np null error");
      {if (true) return "false";}
    }
    throw new Error("Missing return statement in function");
  }

  final public void realDelete(String tblName, BooleanValueExpression bve) throws ParseException {
    int deleteCnt = 0;
    int referentialCnt = 0;
    ArrayList<Integer> deleteIndices = new ArrayList<Integer>();
    Vector<String> records = myDB.getDB(tblName + " @records");

        for(int i=0; i<records.size(); i++) {
          String bveResult;
          String record = records.elementAt(i);
      ArrayList<String> values = split(record.substring(1), "|");

      if(bve == null) { bveResult = "true"; }
      else { bveResult = bve.eval(values, tblName); }

      if(bveResult.equals("false") || bveResult.equals("unknown")) { continue; }
      else {
        // satisfy bve but cannot delete because of referentail integrity
        if(CheckDeleteReferentialIntegrity(tblName, values)) { referentialCnt++; }
        else {
          // yay! can delete this record
          // but caution : list cannot delete in "for"
          // just add delete index
          deleteCnt++;
          deleteIndices.add(i);
        }
      }
    }


    myDB.deleteDB(tblName + " @records");
        // use deleteIndices;
    for(int i=0; i<records.size(); i++) {
      // not delete record
      if(!deleteIndices.contains(i)) {
        myDB.putDB(tblName + " @records", records.elementAt(i));
      }
      else {
                //delete records, so need to cascade
                ArrayList<String> values = split(records.get(i), "|");
                cascade(tblName, values);
      }
    }

    // print delete message
    System.out.println(deleteCnt + " row(s) are deleted");
    if(referentialCnt != 0) { System.out.println(referentialCnt + " row(s) are not deleted due to referential integrity"); }
  }

  final public ArrayList<String> findRefTables(String tblName) throws ParseException {
    ArrayList<String> resultTblNames = new ArrayList<String>();
    Vector<String> tblNames = myDB.getDB("@table name");

    for(String tbl : tblNames) {
      Vector<String> fks = myDB.getDB(tbl + " @foreign key");

      for(String fk : fks) {
        String refTblName = split(split(fk, "&").get(1), "|").get(0);
        if(refTblName.equals(tblName)) {
          resultTblNames.add(tbl);
          break;
        }
      }
    }

    {if (true) return resultTblNames;}
    throw new Error("Missing return statement in function");
  }

// if found, return fkc
// if not found, return null;
  final public String findFKC(String myTblName, String targetTblName) throws ParseException {
        Vector<String> fkcs = myDB.getDB(myTblName + " @foreign key");
        for(String fkc : fkcs) {
          String refTblName = split(split(fkc, "&").get(1), "|").get(0);
          if(refTblName.equals(targetTblName)) { {if (true) return fkc;} }
        }
        System.out.println("findFKC, refTbl not exist error");
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

// check delete referential integrity for tblName's record
// values equals record
  final public boolean CheckDeleteReferentialIntegrity(String tblName, ArrayList<String> values) throws ParseException {
    // find tables who reference me
    ArrayList<String> refTblNames = findRefTables(tblName);
    for(String tbl : refTblNames) {
      String fkc = findFKC(tbl, tblName);
      if(fkc == null) { System.out.println("CheckDeleteReferentialIntegrity, fkc non exist error"); {if (true) return false;}}

      ArrayList<String> fcColumns = split(split(fkc, "@").get(0), "|");
      ArrayList<String> myColumns = split(split(fkc, "&").get(1), "|");
      // because myColumn.get(0) is <tableName>
      myColumns.remove(0);

      boolean isNonNullableColumnExist = false;

      // check foreign key
      ArrayList<String> pks = split(myDB.getDB(tbl + " @primary key").elementAt(0), "|");
      for(String cn : fcColumns) {
        if(pks.contains(cn)) { isNonNullableColumnExist = true; break; }
      }

      // check colDef
      String colDef = myDB.getDB(tbl + " @column definition").elementAt(0);
      ArrayList<Integer> colIndicesTbl = findColumnIndices(tbl, fcColumns);
      ArrayList<Integer> colIndicesMy = findColumnIndices(tblName, myColumns);

      ArrayList<String> colTypes = getColumns(colDef, "type");

      for(int i=0; i<colIndicesTbl.size(); i++) {
        int colIndex = colIndicesTbl.get(i);
        // colType : int*not null
        String colType = colTypes.get(colIndex);
        if(split(colType, "*").size() == 2) { isNonNullableColumnExist = true; break;}
      }

      Vector<String> records = myDB.getDB(tbl + " @records");
      for(String record : records) {
        ArrayList<String> _values = split(record, "|");
        boolean isValueSame = true;
        for(int i=0; i<colIndicesTbl.size(); i++) {
          int index1 = colIndicesTbl.get(i);
          int index2 = colIndicesMy.get(i);
          String value1 = _values.get(index1);
          String value2 = values.get(index2);
          if(!value1.equals(value2)) { isValueSame = false; }
        }

                // now record's values and my values are same
                if(isNonNullableColumnExist && isValueSame) { {if (true) return true;} }

      }

    } // table loop end

    {if (true) return false;}
    throw new Error("Missing return statement in function");
  }

  final public void cascade(String tblName, ArrayList<String> values) throws ParseException {
    // find tables who reference me
    ArrayList<String> refTblNames = findRefTables(tblName);
    // cascade buffer

    for(String tbl : refTblNames) {
      ArrayList<String> cascadeBuffer = new ArrayList<String>();

      String fkc = findFKC(tbl, tblName);
      if(fkc == null) { System.out.println("CheckDeleteReferentialIntegrity, fkc non exist error"); {if (true) return;} }

      ArrayList<String> fcColumns = split(split(fkc, "@").get(0), "|");
      ArrayList<String> myColumns = split(split(fkc, "&").get(1), "|");
      // because myColumn.get(0) is <tableName>
      myColumns.remove(0);


      ArrayList<Integer> colIndicesTbl = findColumnIndices(tbl, fcColumns);
      ArrayList<Integer> colIndicesMy = findColumnIndices(tblName, myColumns);


      Vector<String> records = myDB.getDB(tbl + " @records");
      for(String record : records) {
        ArrayList<String> _values = split(record, "|");
        boolean isValueSame = true;
        for(int i=0; i<colIndicesTbl.size(); i++) {
          int index1 = colIndicesTbl.get(i);
          int index2 = colIndicesMy.get(i);
          String value1 = _values.get(index1);
          String value2 = values.get(index2);
          if(!value1.equals(value2)) { isValueSame = false; }
        }

                // now record's values and my values are same
                if(isValueSame) {
                  // change reference columns to null
                  for(int i=0; i<colIndicesTbl.size(); i++) {
                    int index = colIndicesTbl.get(i);
                    _values.set(index, "null");
                  }
                  String _record = "";
                  for(int i=0; i<_values.size(); i++) {
                    _record = _record + "|" + _values.get(i);
                  }
                  cascadeBuffer.add(_record.substring(1));
                }
                else { cascadeBuffer.add(record); }

      }


      // main cascade
      myDB.deleteDB(tbl + " @records");
      for(int i=0; i<cascadeBuffer.size(); i++) {
        myDB.putDB(tbl + " @records", cascadeBuffer.get(i));
      }

    } // table loop end


    {if (true) return;}
  }

  final public int DeleteQuery() throws ParseException {
  String tblName; BooleanValueExpression bve = null;
    jj_consume_token(DELETE_FROM);
    tblName = TableName();
    if (CheckNoSuchTable(tblName))
    {
      NoSuchTable();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      bve = WhereClause();
      break;
    default:
      jj_la1[31] = jj_gen;
      ;
    }
    ArrayList<String> tblNames = new ArrayList<String>();
    tblNames.add(tblName);
    // delete later start
    //if(bve != null) { bve.print(); }
    // else { System.out.println("no bve"); }
        // delete later end

        if(CheckWhereTableNotSpecifiedError(tblNames, bve)) {
                System.out.println("Where clause try to reference tables which are not specified");
                handleDBError(parser);
        }
        else if(CheckWhereColumnNotExistError(tblNames, bve)) {
                System.out.println("Where clause try to reference non existing column");
                handleDBError(parser);
        }
        else if(CheckWhereAmbiguousReferenceError(tblNames, bve)) {
                System.out.println("Where clause contains ambiguous reference");
                handleDBError(parser);
        }
    else if(CheckWhereIncomparableError(tblNames, bve)) {
                System.out.println("Where clause try to compare incomparable values");
                handleDBError(parser);
    }

    realDelete(tblNames.get(0), bve);
    {if (true) return 6;}
    throw new Error("Missing return statement in function");
  }

  final public boolean IsKeyword(String s) throws ParseException {
    {if (true) return keywordSet.contains(s.toLowerCase());}
    throw new Error("Missing return statement in function");
  }

  final public void Success(int i) throws ParseException {
    switch (i)
    {
      case 0 :
      CreateTableSuccess();
      break;
      case 1 :
      DropSuccess();
      break;
      case 4 :
      break;
      case 5 :
      InsertSuccess();
      break;
      case 6 :
      break;
      case - 1 : myDB.closeDB();
      System.exit(0);
      break;
    }
  }

  final public void Start() throws ParseException {
  Token t;
    System.out.print("DB_2012-11249 > ");
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXIT:
      case RECORDS:
      case DELETE_AT:
      case CREATE_TABLE:
      case DROP_TABLE:
      case SHOW_TABLES:
      case DESC:
      case SELECT:
      case INSERT_INTO:
      case DELETE_FROM:
        ;
        break;
      default:
        jj_la1[32] = jj_gen;
        break label_9;
      }
      Command();
    }
    System.out.println("Syntax error");
    parser = new SimpleDBMS(System.in);
    handleSyntaxError(parser);
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_3R_10() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_21()) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) return true;
    }
    return false;
  }

  private boolean jj_3_5() {
    if (jj_3R_15()) return true;
    if (jj_3R_16()) return true;
    return false;
  }

  private boolean jj_3_8() {
    if (jj_3R_19()) return true;
    return false;
  }

  private boolean jj_3R_19() {
    if (jj_3R_17()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_10()) return true;
    return false;
  }

  private boolean jj_3R_15() {
    if (jj_scan_token(FROM)) return true;
    if (jj_3R_25()) return true;
    return false;
  }

  private boolean jj_3R_35() {
    if (jj_3R_40()) return true;
    return false;
  }

  private boolean jj_3R_34() {
    if (jj_3R_10()) return true;
    return false;
  }

  private boolean jj_3R_28() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_33()) {
    jj_scanpos = xsp;
    if (jj_3R_34()) {
    jj_scanpos = xsp;
    if (jj_3R_35()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_33() {
    if (jj_3R_19()) return true;
    return false;
  }

  private boolean jj_3R_27() {
    if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_7() {
    if (jj_3R_18()) return true;
    return false;
  }

  private boolean jj_3R_17() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_27()) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) return true;
    }
    return false;
  }

  private boolean jj_3R_18() {
    if (jj_3R_28()) return true;
    if (jj_scan_token(COMP_OP)) return true;
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_14() {
    if (jj_3R_10()) return true;
    if (jj_scan_token(AS)) return true;
    if (jj_3R_10()) return true;
    return false;
  }

  private boolean jj_3R_53() {
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3R_52() {
    if (jj_3R_18()) return true;
    return false;
  }

  private boolean jj_3R_50() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) return true;
    }
    return false;
  }

  private boolean jj_3_1() {
    if (jj_3R_10()) return true;
    if (jj_3R_11()) return true;
    if (jj_scan_token(NOT_NULL)) return true;
    return false;
  }

  private boolean jj_3R_24() {
    if (jj_scan_token(DATE)) return true;
    return false;
  }

  private boolean jj_3R_13() {
    if (jj_3R_17()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_10()) return true;
    return false;
  }

  private boolean jj_3R_51() {
    if (jj_scan_token(LEFT_PAREN)) return true;
    if (jj_3R_26()) return true;
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_3R_14()) return true;
    return false;
  }

  private boolean jj_3R_12() {
    if (jj_3R_17()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_10()) return true;
    if (jj_scan_token(AS)) return true;
    if (jj_3R_10()) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_13()) return true;
    return false;
  }

  private boolean jj_3R_49() {
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3R_48() {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_47() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) return true;
    }
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_12()) return true;
    return false;
  }

  private boolean jj_3R_23() {
    if (jj_scan_token(CHAR)) return true;
    if (jj_scan_token(LEFT_PAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(50)) {
    jj_scanpos = xsp;
    if (jj_scan_token(15)) return true;
    }
    if (jj_scan_token(RIGHT_PAREN)) return true;
    return false;
  }

  private boolean jj_3R_42() {
    if (jj_scan_token(NOT)) return true;
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_11() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_22()) {
    jj_scanpos = xsp;
    if (jj_3R_23()) {
    jj_scanpos = xsp;
    if (jj_3R_24()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_22() {
    if (jj_scan_token(INT)) return true;
    return false;
  }

  private boolean jj_3R_41() {
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_38() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_41()) {
    jj_scanpos = xsp;
    if (jj_3R_42()) return true;
    }
    return false;
  }

  private boolean jj_3R_39() {
    if (jj_scan_token(AND)) return true;
    if (jj_3R_38()) return true;
    return false;
  }

  private boolean jj_3R_31() {
    if (jj_3R_38()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_39()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_59() {
    if (jj_scan_token(IS_NOT_NULL)) return true;
    return false;
  }

  private boolean jj_3R_58() {
    if (jj_scan_token(IS_NULL)) return true;
    return false;
  }

  private boolean jj_3R_57() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_58()) {
    jj_scanpos = xsp;
    if (jj_3R_59()) return true;
    }
    return false;
  }

  private boolean jj_3R_32() {
    if (jj_scan_token(OR)) return true;
    if (jj_3R_31()) return true;
    return false;
  }

  private boolean jj_3_9() {
    if (jj_3R_20()) return true;
    return false;
  }

  private boolean jj_3R_26() {
    if (jj_3R_31()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_32()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_20() {
    if (jj_3R_17()) return true;
    if (jj_scan_token(PERIOD)) return true;
    if (jj_3R_10()) return true;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_3R_17()) return true;
    if (jj_scan_token(AS)) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3R_16() {
    if (jj_scan_token(WHERE)) return true;
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3R_56() {
    if (jj_3R_10()) return true;
    if (jj_3R_57()) return true;
    return false;
  }

  private boolean jj_3R_55() {
    if (jj_3R_20()) return true;
    if (jj_3R_57()) return true;
    return false;
  }

  private boolean jj_3R_54() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) return true;
    }
    return false;
  }

  private boolean jj_3R_37() {
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3R_36() {
    if (jj_3R_17()) return true;
    if (jj_scan_token(AS)) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  private boolean jj_3R_29() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_36()) {
    jj_scanpos = xsp;
    if (jj_3R_37()) return true;
    }
    return false;
  }

  private boolean jj_3R_46() {
    if (jj_scan_token(CHAR_STRING)) return true;
    return false;
  }

  private boolean jj_3R_45() {
    if (jj_scan_token(DIGIT)) return true;
    return false;
  }

  private boolean jj_3R_44() {
    if (jj_scan_token(INT_VALUE)) return true;
    return false;
  }

  private boolean jj_3R_43() {
    if (jj_scan_token(DATE_VALUE)) return true;
    return false;
  }

  private boolean jj_3R_40() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_30() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_29()) return true;
    return false;
  }

  private boolean jj_3R_21() {
    if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_25() {
    if (jj_3R_29()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_30()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  /** Generated Token Manager. */
  public SimpleDBMSTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[33];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x6,0x106,0x3c00000,0x3c00000,0x1000,0x18080000,0x80000,0x18000000,0x1000,0x8000,0xc0000000,0x80000,0x80000,0x1000,0x80008,0x80000,0x0,0x1000,0x80000,0x0,0x0,0x88400,0x88400,0x80000,0x88000,0x8000,0x80000,0x0,0x400,0x1000,0x8000,0x0,0x3c00000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x1201e,0x1201e,0x0,0x20000,0x20000,0x0,0x0,0x40000,0x1,0x20000,0x20000,0x0,0x20000,0x20000,0x40,0x0,0x20000,0x200,0x100,0x1e0400,0x1e0000,0x20000,0x1e0000,0x1c0000,0x20000,0x1800,0x0,0x0,0x1c8000,0x80,0x1201e,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[9];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public SimpleDBMS(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SimpleDBMS(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SimpleDBMSTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public SimpleDBMS(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SimpleDBMSTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public SimpleDBMS(SimpleDBMSTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(SimpleDBMSTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[53];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 33; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 53; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 9; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}

class myDatabase
{
  static Environment myDBEnvironment = null;
  static Database myDatabase = null;
  static Cursor myDBCursor = null;

  public static void openDB()
  {
    EnvironmentConfig envConfig = new EnvironmentConfig();
    envConfig.setAllowCreate(true);
    myDBEnvironment = new Environment(new File("db/"), envConfig);
    DatabaseConfig dbConfig = new DatabaseConfig();
    dbConfig.setAllowCreate(true);
    dbConfig.setSortedDuplicates(true);
    myDatabase = myDBEnvironment.openDatabase(null, "myDatabase", dbConfig);
    myDBCursor = myDatabase.openCursor(null, null);
  }

  public static void closeDB()
  {
    if (myDBCursor != null) myDBCursor.close();
    if (myDatabase != null) myDatabase.close();
    if (myDBEnvironment != null) myDBEnvironment.close();
  }

  public static void putDB(String key, String value)
  {
    DatabaseEntry _key;
    DatabaseEntry _value;
    try
    {
      _key = new DatabaseEntry(key.getBytes("UTF-8"));
      _value = new DatabaseEntry(value.getBytes("UTF-8"));
      myDBCursor.put(_key, _value);
    }
    catch (DatabaseException de)
    {}
    catch (UnsupportedEncodingException e)
    {
      e.printStackTrace();
    }
  }

  public static Vector<String> getDB(String key)
  {
    Vector<String> valueSet = new Vector<String>();
    Cursor cursor = null;
    try
    {
      DatabaseEntry foundKey = new DatabaseEntry(key.getBytes("UTF-8"));
      DatabaseEntry foundValue = new DatabaseEntry();
      cursor = myDatabase.openCursor(null, null);
      OperationStatus retVal = cursor.getSearchKey(foundKey, foundValue, LockMode.DEFAULT);
      while (retVal == OperationStatus.SUCCESS)
      {
        String valueString = new String(foundValue.getData(), "UTF-8");
        valueSet.addElement(valueString);
        retVal = cursor.getNextDup(foundKey, foundValue, LockMode.DEFAULT);
      }
    }
    catch (Exception e)
    {}
    finally
    {
      cursor.close();
    }
    return valueSet;
  }

  public static void deleteDB(String key)
  {
    try
    {
      DatabaseEntry theKey = new DatabaseEntry(key.getBytes("UTF-8"));
      myDatabase.delete(null, theKey);
    }
    catch (Exception e)
    {}
  }

  // For debugging
  public static void printDB()
  {
    Cursor cursor = null;
    try
    {
      DatabaseEntry foundKey = new DatabaseEntry();
      DatabaseEntry foundData = new DatabaseEntry();
      cursor = myDatabase.openCursor(null, null);
      cursor.getFirst(foundKey, foundData, LockMode.DEFAULT);
      do
      {
        String keyString = new String(foundKey.getData(), "UTF-8");
        String dataString = new String(foundData.getData(), "UTF-8");
        System.out.println("<" + keyString + ", " + dataString + ">");
      }
      while (cursor.getNext(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.SUCCESS);
    }
    catch (Exception e)
    {}
    finally
    {
      cursor.close();
    }
  }

  // For DB error handling and drop table query
  public static void deleteTable(String tblName)
  {
    Cursor cursor = null;
    try
    {
      DatabaseEntry colDef = new DatabaseEntry((tblName + " @column definition").getBytes("UTF-8"));
      DatabaseEntry priKey = new DatabaseEntry((tblName + " @primary key").getBytes("UTF-8"));
      DatabaseEntry forKey = new DatabaseEntry((tblName + " @foreign key").getBytes("UTF-8"));
      myDatabase.delete(null, colDef);
      myDatabase.delete(null, priKey);
      myDatabase.delete(null, forKey);
    }
    catch (Exception e)
    {}
  }
}
