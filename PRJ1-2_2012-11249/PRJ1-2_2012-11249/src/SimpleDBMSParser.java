/* Generated By:JavaCC: Do not edit this line. SimpleDBMSParser.java */
//importimport java.io.*;
import java.util.*;
import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.DatabaseConfig;
import com.sleepycat.je.Cursor;
import com.sleepycat.je.DatabaseEntry;
import com.sleepycat.je.LockMode;
import com.sleepycat.je.OperationStatus;

import com.sleepycat.je.Environment;
import com.sleepycat.je.EnvironmentConfig;


class TableInfo {
        ArrayList<ColumnDef> cdlist;
        ArrayList<PkConstraint> pklist;
        ArrayList<FkConstraint> fklist;

        public TableInfo(ArrayList<ColumnDef> cdlist, ArrayList<PkConstraint> pklist, ArrayList<FkConstraint> fklist) {
                this.cdlist = cdlist;
                this.pklist = pklist;
                this.fklist = fklist;
        }
}

class TableElement {
        String type; // "columnDefinition" or "primaryKeyConstraint" or "foreignKeyConstraint"        ColumnDef columnDef;
        PkConstraint pkConst;
        FkConstraint fkConst;

        public TableElement(String type, ColumnDef cd, PkConstraint pc, FkConstraint fc) {
                this.type = type;
                columnDef = cd;
                pkConst = pc;
                fkConst = fc;
        }
}

class ColumnDef {
        String columnName;
        String dataType;
        String notNull;

        public ColumnDef(String cn, String dt, String nn) {
                columnName = cn;
                dataType = dt;
                notNull = nn;
        }
}
class PkConstraint {
        ArrayList<String> columnNameList;

        public PkConstraint(ArrayList<String> cnlist) {
                columnNameList = cnlist;
        }
}
class FkConstraint {
        ArrayList<String> fkColumnList;
        String refTableName;
        ArrayList<String> refColumnList;

        public FkConstraint(ArrayList<String> fkcl, String rtn, ArrayList<String> rcl) {
                fkColumnList = fkcl;
                refTableName = rtn;
                refColumnList = rcl;
        }
}


public class SimpleDBMSParser implements SimpleDBMSParserConstants {
  // set query number  public static final int PRINT_SYNTAX_ERROR = 0;
  public static final int PRINT_CREATE_TABLE = 1;
  public static final int PRINT_DROP_TABLE = 2;
  public static final int PRINT_DESC = 3;
  public static final int PRINT_SHOW_TABLES = 4;
  public static final int PRINT_SELECT = 5;
  public static final int PRINT_INSERT = 6;
  public static final int PRINT_DELETE = 7;

  public static void printColumnDef(ColumnDef cd) {
        System.out.println("columnName: " + cd.columnName);
        System.out.println("dataType: " + cd.dataType);
        System.out.println("notNull: " + cd.notNull);
  }

  public static void printPkConstraint(PkConstraint pc) {
        for(String s : pc.columnNameList) { System.out.println("pkColumnName: " + s); }
  }

  public static void printFkConstraint(FkConstraint fc) {
        for(String s : fc.fkColumnList) { System.out.println("fkColumnList: " + s); }
        System.out.println("refTableName: " + fc.refTableName);
        for(String s : fc.refColumnList) { System.out.println("refColumnList: " + s); }
  }


  public static void closeDb(Database myDatabase, Environment myDbEnvironment) {
    if(myDatabase != null) { myDatabase.close(); }
    if(myDbEnvironment != null) { myDbEnvironment.close(); }
  }

  public static Boolean isDuplicateColumnDefError(ArrayList<ColumnDef> cdlist) {
        for(int i=0; i<cdlist.size(); i++) {
                for(int j=i+1; j<cdlist.size(); j++) {
                        if(cdlist.get(i).columnName.equalsIgnoreCase(cdlist.get(j).columnName)) {
                                System.out.println("Create table has failed: column definition is duplicated");
                                return true;
                        }
                }
        }

//	for(ColumnDef cd : cdlist) {
//		if(set.add(cd.columnName) == false) {
//		  System.out.println("Create table has failed: column definition is duplicated");
//		  return true;
//		}
//	}
        return false;
  }

  public static Boolean contains(ArrayList<String> list, String s) {
        for(int i=0; i<list.size(); i++) {
                if(list.get(i).equalsIgnoreCase(s)) {
                        return true;
                }
        }
        return false;
  }

  public static Boolean isPrimaryKeyDefError(ArrayList<PkConstraint> pklist, ArrayList<ColumnDef> cdlist) {
        ArrayList<String> cnlist = new ArrayList<String>();
        for(ColumnDef cd : cdlist) {
                cnlist.add(cd.columnName);
        }
        if(pklist.size() == 1) {
                for(String pkcn : pklist.get(0).columnNameList) {
                        if(!contains(cnlist, pkcn)) { System.out.println("Create table has failed: '" + pkcn +  "'does not exists in column definition"); return true; }
                }
                return false;
        }
        else if(pklist.size() == 0) {
            // case : new error, primary key constraint not exist                System.out.println("Create table has failed: primary key not defined");
                return true;
        }
        else if(pklist.size() > 1) {
            // case : DuplicatePrimaryKeyError                System.out.println("Create table has failed: primary key definition is duplicated");
                return true;
        }
        else {
            // case : new error, strange number like negative                 System.out.println("Create table has failed: primary key definition strange number");
                return true;
        }


  }

  public static String findType(ArrayList<ColumnDef> cdlist, String cn) {
        for(ColumnDef cd : cdlist) {
          //System.out.println("findTypeStart");          //System.out.println("cd.columnName: " + cd.columnName);          //System.out.println("cn: " + cn);          //System.out.println("findTypeEnd");


                if(cd.columnName.equalsIgnoreCase(cn)) {
                        return cd.dataType;
                }
        }
        //System.out.println("findType non exist;");        return "fail findType";
  }

  public static ArrayList<String> getStringByKey(Database myDatabase, String key) {
        Cursor cursor = null;
        String searchKey = key.toLowerCase();
        ArrayList<String> valueList = new ArrayList<String>();
        try {
            // Create DatabaseEntry objects            // searchKey is key String.            DatabaseEntry theKey = new DatabaseEntry(searchKey.getBytes("UTF-8"));
            DatabaseEntry theData = new DatabaseEntry();

            // Open a cursor using a database handle            cursor = myDatabase.openCursor(null, null);

            // Position the cursor            // Ignoring the return value for clarity            OperationStatus retVal = cursor.getSearchKey(theKey, theData,
                                                         LockMode.DEFAULT);

            // Count the number of duplicates. If the count is greater than 1,             // print the duplicates.
        while (retVal == OperationStatus.SUCCESS) {
            String keyString = new String(theKey.getData(), "UTF-8");
            String dataString = new String(theData.getData(), "UTF-8");
            valueList.add(dataString);
            retVal = cursor.getNextDup(theKey, theData, LockMode.DEFAULT);
        }
        return valueList;
        } catch (Exception e) {
            e.printStackTrace();
            return valueList;
        } finally {
           // Make sure to close the cursor           cursor.close();
        }
  }

  public static Boolean isReferenceError(Database myDatabase, ArrayList<FkConstraint> fklist, ArrayList<ColumnDef> cdlist) {
        for(FkConstraint fkc : fklist) {
                int fksize = 0;
                int refFksize = 0;
                fksize = fkc.fkColumnList.size();
                refFksize = fkc.refColumnList.size();
                // case1 : different number of columns, ReferenceTypeError                if(fksize != refFksize) {
                        System.out.println("Create table has failed: foreign key references wrong type");
                        return true;
                }

                String fkTableName = fkc.refTableName;
                ArrayList<String> tableNameList = getStringByKey(myDatabase, "TableName");
                // case : ReferenceTableExistenceError                if(!contains(tableNameList, fkTableName)) { System.out.println("Create table has failed: foreign key references non existing table"); return true;}

                ArrayList<String> cnlist = new ArrayList<String>();
                for(ColumnDef cd : cdlist) {
                        cnlist.add(cd.columnName);
                }

                for(int i=0; i<fksize; i++) {
                        String fkColumn = fkc.fkColumnList.get(i);
                        String refFkColumn = fkc.refColumnList.get(i);
                        String fkType = findType(cdlist, fkColumn);
                        ArrayList<String> valueList = getStringByKey(myDatabase, fkTableName + "." + refFkColumn);
                        //System.out.println("asdkjfhkjs: " + fkTableName + "." + refFkColumn);                        //for(String s : valueList) {                        //	System.out.println(s);                        //}                        //System.out.println("kjashdjkrhsk");                        // case : NonExistingColumnDefError                        if(!contains(cnlist, fkColumn)) { System.out.println("Create table has failed: '" + fkColumn + "' does not exists in column definition"); return true; }

                        // case : foreign key references non exist column, ReferenceColumnExistenceError                        if(valueList.size() == 0) { System.out.println("Create table has failed: foreign key references non existing column"); return true;}
                        if(valueList.size() != 1) { System.out.println("multi column name error"); } //return;                         String[] columnInfo = valueList.get(0).split(",");
                        String refFkType = columnInfo[0];
                        // case : foreign key column and reference column has diffenrent type, ReferenceTypeError                        if(!fkType.equalsIgnoreCase(refFkType)) {
                                //System.out.println("fkColumn: " + fkColumn);                                //System.out.println("refFkColumn: " + refFkColumn);                                //System.out.println("fkType: " + fkType);                                //System.out.println("refFkType: " + refFkType);                                System.out.println("Create table has failed: foreign key references wrong type");
                                return true;
                        }
                        // case : foreign key references non primary key , ReferenceNonPrimaryKeyError                        if(!columnInfo[2].equalsIgnoreCase("Y")) {
                                System.out.println("Create table has failed: foreign key references non primary key column");
                                return true;
                        }

                }



        } // fklist iterate        // not case1 nor case2        return false;
  }

  public static Boolean isTableExistenceError(Database myDatabase, String tableName) {
        ArrayList<String> tableNameList = getStringByKey(myDatabase, "TableName");
        // case : TableExistenceError        if(contains(tableNameList, tableName)) { System.out.println("Create table has failed: table with the same name already exists"); return true; }
        return false;
  }

  public static void insertData(Database myDatabase, String theKey, String theData) {
        Cursor cursor = null;
        DatabaseEntry key;
        DatabaseEntry data;
        try {
          cursor = myDatabase.openCursor(null, null);
          key = new DatabaseEntry(theKey.toLowerCase().getBytes("UTF-8"));
          data = new DatabaseEntry(theData.getBytes("UTF-8"));
          cursor.put(key, data);

        } catch(Exception e) {
            e.printStackTrace();
            return;
        } finally {
                cursor.close();
        }

        return;
  }

 // public static void deleteData(Database ) {
 // }
  public static Boolean isCharError(ArrayList<ColumnDef> cdlist) {
        for(ColumnDef cd : cdlist) {
                // dataType = char(value)                if(cd.dataType.length() > 4) {
                        String value;
                        StringBuilder sb = new StringBuilder();

                        //System.out.println(cd.dataType);                        for(int i=0; i<cd.dataType.length(); i++) {
                          char c = cd.dataType.charAt(i);
                          //System.out.println(c);                          if((c >= '0' && c <= '9')  || c == '-') {
                                //System.out.println("hi");                            sb.append(c);
                          }
                        }
                        value = sb.toString();
                        //System.out.println("value: " + value);                        if(Integer.parseInt(value) < 1) {
                                System.out.println("Char length should be over 0");
                                return true;
                        }
                }
        }
        return false;
  }

  public static void printAllKeyValue(Database myDatabase) {
        System.out.println("printAllKeyValue------------------------------------");
        int recordCnt = 0;
        DatabaseEntry foundKey = new DatabaseEntry();
        DatabaseEntry foundData = new DatabaseEntry();
        Cursor cursor = myDatabase.openCursor(null, null);

        cursor.getFirst(foundKey, foundData, LockMode.DEFAULT);

        do {
          try {
                String keyString = new String(foundKey.getData(), "UTF-8");
                String dataString = new String(foundData.getData(), "UTF-8");
                System.out.println("key: " + keyString + "@@ value: " + dataString);
                recordCnt++;
          } catch(Exception e) {
            System.out.println("error in printAllKeyValue, body is below");
                e.printStackTrace();
                cursor.close();
          }
        } while(cursor.getNext(foundKey, foundData, LockMode.DEFAULT) == OperationStatus.SUCCESS);

        System.out.println("#records: " + recordCnt);
        cursor.close();
  }

  public static void createTable(Database myDatabase, String tn, ArrayList<TableElement> telist) {
        //ArrayList<String> errorMessageList = new ArrayList<String>();        ArrayList<ColumnDef> cdlist = new ArrayList<ColumnDef>();
        ArrayList<PkConstraint> pklist = new ArrayList<PkConstraint>();
        ArrayList<FkConstraint> fklist = new ArrayList<FkConstraint>();
        Boolean error = false;
        Cursor cursor = null;
        DatabaseEntry key;
        DatabaseEntry data;

        //make cdlist, pklist, fklist        for(TableElement te : telist) {
                if(te.type.equalsIgnoreCase("columnDefinition")) {
                        cdlist.add(te.columnDef);
                }
                else if(te.type.equalsIgnoreCase("primaryKeyConstraint")) {
                        pklist.add(te.pkConst);
                }
                else if(te.type.equalsIgnoreCase("foreignKeyConstraint")) {
                        fklist.add(te.fkConst);
                }
                else {
                        System.out.println("telist type error!");
                }
        }

        //for(ColumnDef c : cdlist) { printColumnDef(c); }        //for(PkConstraint p : pklist) { printPkConstraint(p); }        //for(FkConstraint f : fklist) { printFkConstraint(f); }
        error = error | isDuplicateColumnDefError(cdlist);
        error = error | isPrimaryKeyDefError(pklist, cdlist);
        error = error | isTableExistenceError(myDatabase, tn);
        error = error | isReferenceError(myDatabase, fklist, cdlist);
        error = error | isCharError(cdlist);


        // let's store data and print success message because error doesn't exist        if(!error) {
          // print success message          System.out.println("'" + tn + "' table is created");

          // store data (key, value)          // 1: ("TableName", tn), 2: (<tableName>.columnDef, "cn,dt,nn"), 3: (<taleName>.<columnName>, "dt,nn,pk,fk")          // 4: (<tableName>.primaryKey, "cn") , 5: (<tableName>.foreignKey, "@cn,cn, ...cn@tn@cn, ...cn")          // insertData(myDatabase, key, data);
          // 1: ("TableName", tn)          insertData(myDatabase, "TableName", tn);

          for(ColumnDef cd : cdlist) {
                // 3: (<taleName>.<columnName>, "dt,nn,pk,fk")                String isPk = "N";
                String isFk = "N";
                if(contains(pklist.get(0).columnNameList, cd.columnName)) {
                  isPk = "Y";
                  cd.notNull = "notNull";
                }
                for(FkConstraint fkc : fklist) {
                        if(contains(fkc.fkColumnList, cd.columnName)) { isFk = "Y"; }
                }
                insertData(myDatabase, tn + "." + cd.columnName, cd.dataType + "," + cd.notNull + "," + isPk + "," + isFk);
            // 2: (<tableName>.columnDef, "cn,dt,nn")                String theData = cd.columnName + "," + cd.dataType + "," + cd.notNull;
                insertData(myDatabase, tn + ".columnDef", theData);

          }
          // 4: (<tableName>.primaryKey, "cn")          for(String cn : pklist.get(0).columnNameList) {
                insertData(myDatabase, tn + ".primaryKey", cn);
          }
          // 5: (<tableName>.foreignKey, "@cn,cn, ...cn@tn@cn, ...cn")          for(FkConstraint fkc : fklist) {
                String theData = "";
                for(int i=0; i<fkc.fkColumnList.size(); i++) {
                        theData = theData + fkc.fkColumnList.get(i);
                        if(i < fkc.fkColumnList.size()-1) { theData = theData + ","; }
                }
                theData = theData + "@" + fkc.refTableName + "@";
                for(int i=0; i<fkc.refColumnList.size(); i++) {
                        theData = theData + fkc.refColumnList.get(i);
                        if(i < fkc.refColumnList.size()-1) { theData = theData + ","; }
                }

                insertData(myDatabase, tn + ".foreignKey", theData);
          }

        }


        return;
  }

  public static void showTables(Database myDatabase) {
        ArrayList<String> tnlist = getStringByKey(myDatabase, "TableName");
        // case : ShowTablesNoTable        if(tnlist.size() == 0) {
          System.out.println("There is no table");
          return;
        }

        System.out.println("----------------");
        for(String tn : tnlist) {
                System.out.println(tn);
        }

        System.out.println("----------------");

        //printAllKeyValue(myDatabase);  }

  public static void desc(Database myDatabase, String tn) {
        ArrayList<String> tnlist = getStringByKey(myDatabase, "TableName");
        // case : NoSuchTable        if(!contains(tnlist, tn)) { System.out.println("No such table"); return; }
        ArrayList<String> cdlist = getStringByKey(myDatabase, tn+".columnDef");

        System.out.println("-------------------------------------------------");
        System.out.println("table_name [" + tn + "]");
        String COLUMNNAME = "column_name";
        String TYPE = "type";
        String NULL = "null";
        String KEY = "key";
        System.out.printf("%-20s %-10s %-10s %-10s\u005cn", COLUMNNAME, TYPE, NULL, KEY);

        // extract column names of tn        for(String cd : cdlist) {
                String cn = cd.split(",")[0];
                String dtnnpkfk = getStringByKey(myDatabase, tn + "." + cn).get(0);
                //System.out.println("cn: " + cn);                //System.out.println("dtnnpkfk: " + dtnnpkfk);                String buf[] = dtnnpkfk.split(",");
                String dt = buf[0], nn = buf[1], pk = buf[2], fk = buf[3];
                //System.out.println("dt: " + dt);                //System.out.println("nn: " + nn);                //System.out.println("pk: " + pk);                //System.out.println("fk: " + fk);
                // not null check                if(nn.equalsIgnoreCase("null")) { nn = "Y"; }
                else if(nn.equalsIgnoreCase("notNull")) { nn = "N"; }
                else { System.out.println("desc nn error"); return; }
                // primary key, foreign key check                String pkfk = "";
                if(pk.equalsIgnoreCase("Y") && fk.equalsIgnoreCase("Y")) { pkfk = "PRI/FOR"; }
                else if(pk.equalsIgnoreCase("Y") && fk.equalsIgnoreCase("N")) { pkfk = "PRI"; }
                else if(pk.equalsIgnoreCase("N") && fk.equalsIgnoreCase("Y")) { pkfk = "FOR"; }

                System.out.printf("%-20s %-10s %-10s %-10s\u005cn", cn, dt, nn, pkfk);
        }

        System.out.println("-------------------------------------------------");
  }

  public static void deleteData(Database myDatabase, String aKey) {

        try {
            DatabaseEntry theKey = new DatabaseEntry(aKey.toLowerCase().getBytes("UTF-8"));
            // Perform the deletion. All records that use this key are            // deleted.            myDatabase.delete(null, theKey);
        } catch (Exception e) {
            // Exception handling goes here            System.out.println("deleteData error");
        }
  }
  public static void dropTable(Database myDatabase, String tn) {
        ArrayList<String> tnlist = getStringByKey(myDatabase, "TableName");
        // case : NoSuchTable
        if(!contains(tnlist, tn)) { System.out.println("No such table"); return; }

        Boolean isRefeeExist = false;


        for(String s : tnlist) {
          if(!s.equalsIgnoreCase(tn)) {
                        ArrayList<String> fklist = getStringByKey(myDatabase, s + ".foreignKey");
                        ArrayList<String> refTablenameList = new ArrayList<String>();
                        for(String p : fklist) {
                                String reftn = p.split("@")[1];
                                refTablenameList.add(reftn);
                                //System.out.println("reftn: " + reftn);                                //System.out.println("refTablenameList: " + refTablenameList);
                        }
                        //System.out.println("tn: " + tn);
                        if(contains(refTablenameList, tn)) { isRefeeExist = true; break; }
                }
        }
        // case : DropReferencedTableError
        if(isRefeeExist) { System.out.println("Drop table has failed: '" + tn + "' is referenced by other table"); return; }

        // ok, let's remove data

        ArrayList<String> cnlist = new ArrayList<String>();
        ArrayList<String> cdlist = getStringByKey(myDatabase, tn + ".columnDef");
        for(String cd : cdlist) {
                String cn = cd.split(",")[0];
                cnlist.add(cn);
        }
        // delete table info        deleteData(myDatabase, tn + ".columnDef");
        deleteData(myDatabase, tn + ".primaryKey");
        deleteData(myDatabase, tn + ".foreignKey");
        for(String s : cnlist) {
                deleteData(myDatabase, tn + "." + s);
        }

        // delete table name        Cursor cursor = null;
        try {
            // Create DatabaseEntry objects            // use TableName.toLowerCase()            DatabaseEntry theKey = new DatabaseEntry("tablename".getBytes("UTF-8"));
            DatabaseEntry theData = new DatabaseEntry();

            // Open a cursor using a database handle            cursor = myDatabase.openCursor(null, null);

            // Position the cursor. Ignoring the return value for clarity            OperationStatus retVal = cursor.getSearchKey(theKey, theData,
                                                         LockMode.DEFAULT);
                 while (retVal == OperationStatus.SUCCESS) {
            String keyString = new String(theKey.getData(), "UTF-8");
            String dataString = new String(theData.getData(), "UTF-8");
            //System.out.println("dataString: " + dataString);            if(dataString.equalsIgnoreCase(tn)) {
                                cursor.delete();
                                break;
            }
            retVal = cursor.getNextDup(theKey, theData, LockMode.DEFAULT);
          }

        } catch (Exception e) {
                System.out.println("delete table name error");
            e.printStackTrace();
            return;
        } finally {
           // Make sure to close the cursor           cursor.close();
        }




        System.out.println("'" + tn + "' table is dropped");

  }

  public static void main(String args[]) throws ParseException
  {

    // Environment & Database define        Environment myDbEnvironment = null;
        Database myDatabase = null;

    /* OPENING DB */
    // Open Database Environment or if not, create one.    EnvironmentConfig envConfig = new EnvironmentConfig();
    envConfig.setAllowCreate(true);
    myDbEnvironment = new Environment(new File("db/"), envConfig);

    // Open Database or if not, create one.    DatabaseConfig dbConfig = new DatabaseConfig();
    dbConfig.setAllowCreate(true);
    dbConfig.setSortedDuplicates(true);
    myDatabase = myDbEnvironment.openDatabase(null, "myDatabase", dbConfig);

    SimpleDBMSParser parser = new SimpleDBMSParser(System.in);
    System.out.print("DB_2012-11249> ");

    while (true)
    {

      try
      {
        parser.command(myDatabase, myDbEnvironment);
      }
      catch (Exception e)
      {
        printMessage(PRINT_SYNTAX_ERROR);
                //e.printStackTrace();        SimpleDBMSParser.ReInit(System.in);
      }
    }


  }

  public static void printMessage(int q)
  {
    switch(q)
    {
      case PRINT_SYNTAX_ERROR:
        System.out.println("Syntax error");
        break;
      case PRINT_CREATE_TABLE:
        System.out.println("\u005c'CREATE TABLE\u005c' requested");
        break;
      case PRINT_DROP_TABLE:
        System.out.println("\u005c'DROP TABLE\u005c' requested");
        break;
      case PRINT_DESC:
        System.out.println("\u005c'DESC\u005c' requested");
        break;
      case PRINT_SHOW_TABLES:
        System.out.println("\u005c'SHOW TABLES\u005c' requested");
        break;
      case PRINT_SELECT:
        System.out.println("\u005c'SELECT\u005c' requested");
        break;
      case PRINT_INSERT:
        System.out.println("\u005c'INSERT\u005c' requested");
        break;
      case PRINT_DELETE:
        System.out.println("\u005c'DELETE\u005c' requested");
        break;
    }
    System.out.print("DB_2012-11249> ");
  }

  static final public void command(Database myDatabase, Environment myDbEnvironment) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CREATE_TABLE:
    case DROP_TABLE:
    case DESC:
    case SHOW_TABLES:
    case SELECT:
    case INSERT_INTO:
    case DELETE_FROM:
      queryList(myDatabase);
      break;
    case EXIT:
      jj_consume_token(EXIT);
      jj_consume_token(SEMICOLON);
      closeDb(myDatabase, myDbEnvironment);
      System.exit(0);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void queryList(Database myDatabase) throws ParseException {
  int q;
    label_1:
    while (true) {
      q = query(myDatabase);
      jj_consume_token(SEMICOLON);
      printMessage(q);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CREATE_TABLE:
      case DROP_TABLE:
      case DESC:
      case SHOW_TABLES:
      case SELECT:
      case INSERT_INTO:
      case DELETE_FROM:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
    }
  }

  static final public int query(Database myDatabase) throws ParseException {
  int q;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CREATE_TABLE:
      createTableQuery(myDatabase);
                                   q = -1; {if (true) return q;}
      break;
    case DROP_TABLE:
      dropTableQuery(myDatabase);
                                 q = -1; {if (true) return q;}
      break;
    case DESC:
      descQuery(myDatabase);
                            q = -1; {if (true) return q;}
      break;
    case SELECT:
      selectQuery();
                    q = PRINT_SELECT; {if (true) return q;}
      break;
    case INSERT_INTO:
      insertQuery();
                    q = PRINT_INSERT; {if (true) return q;}
      break;
    case DELETE_FROM:
      deleteQuery();
                    q = PRINT_DELETE; {if (true) return q;}
      break;
    case SHOW_TABLES:
      showTablesQuery(myDatabase);
                                  q = -1; {if (true) return q;}
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public void createTableQuery(Database myDatabase) throws ParseException {
  String tableName = null;
  ArrayList<TableElement> tableElementList = null;
  int success;
    jj_consume_token(CREATE_TABLE);
    tableName = tableName();
    tableElementList = tableElementList();
        //create Function
        createTable(myDatabase, tableName, tableElementList);
  }

  static final public ArrayList<TableElement> tableElementList() throws ParseException {
        ArrayList<TableElement> telist = new ArrayList<TableElement>();
        TableElement te;
    jj_consume_token(LEFT_PAREN);
    te = tableElement();
    telist.add(te);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_2;
      }
      jj_consume_token(COMMA);
      te = tableElement();
    telist.add(te);
    }
    jj_consume_token(RIGHT_PAREN);
    {if (true) return telist;}
    throw new Error("Missing return statement in function");
  }

  static final public TableElement tableElement() throws ParseException {
  TableElement te;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEGAL_IDENTIFIER:
      te = columnDefinition();
                            {if (true) return te;}
      break;
    case PRIMARY_KEY:
    case FOREIGN_KEY:
      te = tableConstraintDefinition();
                                                                              {if (true) return te;}
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public TableElement columnDefinition() throws ParseException {
  String cn; String dt; String nn = "null";
    cn = columnName();
    dt = dataType();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT_NULL:
      jj_consume_token(NOT_NULL);
                   nn = "notNull" ;
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
        {if (true) return new TableElement("columnDefinition", new ColumnDef(cn, dt, nn), null, null);}
    throw new Error("Missing return statement in function");
  }

  static final public TableElement tableConstraintDefinition() throws ParseException {
  TableElement te;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMARY_KEY:
      te = primaryKeyConstraint();
                                {if (true) return te;}
      break;
    case FOREIGN_KEY:
      te = referentialConstraint();
                                                                              {if (true) return te;}
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public TableElement primaryKeyConstraint() throws ParseException {
  ArrayList<String> cnlist = new ArrayList<String>();
    jj_consume_token(PRIMARY_KEY);
    cnlist = columnNameList();
                              {if (true) return new TableElement("primaryKeyConstraint", null, new PkConstraint(cnlist), null);}
    throw new Error("Missing return statement in function");
  }

  static final public TableElement referentialConstraint() throws ParseException {
  ArrayList<String> fkcl = new ArrayList<String>(); String refTableName; ArrayList<String> rcl = new ArrayList<String>();
    jj_consume_token(FOREIGN_KEY);
    fkcl = columnNameList();
    jj_consume_token(REFERENCES);
    refTableName = tableName();
    rcl = columnNameList();
    {if (true) return new TableElement("foreignKeyConstraint", null, null, new FkConstraint(fkcl, refTableName, rcl));}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<String> columnNameList() throws ParseException {
  ArrayList<String> cnlist = new ArrayList<String>(); String cn;
    jj_consume_token(LEFT_PAREN);
    cn = columnName();
                      cnlist.add(cn);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_3;
      }
      jj_consume_token(COMMA);
      cn = columnName();
                                  cnlist.add(cn);
    }
    jj_consume_token(RIGHT_PAREN);
                    {if (true) return cnlist;}
    throw new Error("Missing return statement in function");
  }

  static final public String dataType() throws ParseException {
  Token value;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      jj_consume_token(INT);
            {if (true) return "int";}
      break;
    case CHAR:
      jj_consume_token(CHAR);
      jj_consume_token(LEFT_PAREN);
      value = jj_consume_token(INT_VALUE);
      jj_consume_token(RIGHT_PAREN);
      {if (true) return "char(" + value.image + ")";}
      break;
    case DATE:
      jj_consume_token(DATE);
             {if (true) return "date";}
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public String tableName() throws ParseException {
  Token tableName;
    tableName = jj_consume_token(LEGAL_IDENTIFIER);
                                     {if (true) return tableName.image;}
    throw new Error("Missing return statement in function");
  }

  static final public String columnName() throws ParseException {
  Token columnName;
    columnName = jj_consume_token(LEGAL_IDENTIFIER);
                                      {if (true) return columnName.image;}
    throw new Error("Missing return statement in function");
  }

  static final public void dropTableQuery(Database myDatabase) throws ParseException {
  String tn;
    jj_consume_token(DROP_TABLE);
    tn = tableName();
    dropTable(myDatabase, tn);
  }

  static final public void descQuery(Database myDatabase) throws ParseException {
  String tn;
    jj_consume_token(DESC);
    tn = tableName();
    desc(myDatabase, tn);
  }

  static final public void showTablesQuery(Database myDatabase) throws ParseException {
    jj_consume_token(SHOW_TABLES);
    showTables(myDatabase);
  }

  static final public void selectQuery() throws ParseException {
    jj_consume_token(SELECT);
    selectList();
    tableExpression();
  }

  static final public void selectList() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASTERISK:
      jj_consume_token(ASTERISK);
      break;
    case LEGAL_IDENTIFIER:
      selectedColumn();
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_4;
        }
        jj_consume_token(COMMA);
        selectedColumn();
      }
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void selectedColumn() throws ParseException {
    if (jj_2_1(2)) {
      tableName();
      jj_consume_token(PERIOD);
    } else {
      ;
    }
    columnName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      columnName();
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
  }

  static final public void tableExpression() throws ParseException {
    fromClause();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      whereClause();
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
  }

  static final public void fromClause() throws ParseException {
    jj_consume_token(FROM);
    tableReferenceList();
  }

  static final public void tableReferenceList() throws ParseException {
    referedTable();
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_5;
      }
      jj_consume_token(COMMA);
      referedTable();
    }
  }

  static final public void referedTable() throws ParseException {
    tableName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      tableName();
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
  }

  static final public void whereClause() throws ParseException {
    jj_consume_token(WHERE);
    booleanValueExpression();
  }

  static final public void booleanValueExpression() throws ParseException {
    booleanTerm();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_6;
      }
      jj_consume_token(OR);
      booleanTerm();
    }
  }

  static final public void booleanTerm() throws ParseException {
    booleanFactor();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_7;
      }
      jj_consume_token(AND);
      booleanFactor();
    }
  }

  static final public void booleanFactor() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    booleanTest();
  }

  static final public void booleanTest() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT_VALUE:
    case LEGAL_IDENTIFIER:
    case CHAR_STRING:
    case DATE_VALUE:
      predicate();
      break;
    case LEFT_PAREN:
      parenthesizedBooleanExpression();
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void parenthesizedBooleanExpression() throws ParseException {
    jj_consume_token(LEFT_PAREN);
    booleanValueExpression();
    jj_consume_token(RIGHT_PAREN);
  }

  static final public void predicate() throws ParseException {
    if (jj_2_2(4)) {
      comparisonPredicate();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LEGAL_IDENTIFIER:
        nullPredicate();
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  static final public void comparisonPredicate() throws ParseException {
    compOperand();
    compOp();
    compOperand();
  }

  static final public void compOperand() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT_VALUE:
    case CHAR_STRING:
    case DATE_VALUE:
      comparableValue();
      break;
    case LEGAL_IDENTIFIER:
      if (jj_2_3(2)) {
        tableName();
        jj_consume_token(PERIOD);
      } else {
        ;
      }
      columnName();
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void compOp() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case L:
      jj_consume_token(L);
      break;
    case G:
      jj_consume_token(G);
      break;
    case LE:
      jj_consume_token(LE);
      break;
    case GE:
      jj_consume_token(GE);
      break;
    case EQ:
      jj_consume_token(EQ);
      break;
    case NEQ:
      jj_consume_token(NEQ);
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void comparableValue() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT_VALUE:
      jj_consume_token(INT_VALUE);
      break;
    case CHAR_STRING:
      jj_consume_token(CHAR_STRING);
      break;
    case DATE_VALUE:
      jj_consume_token(DATE_VALUE);
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void nullPredicate() throws ParseException {
    if (jj_2_4(2)) {
      tableName();
      jj_consume_token(PERIOD);
    } else {
      ;
    }
    columnName();
    nullOperation();
  }

  static final public void nullOperation() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IS_NULL:
      jj_consume_token(IS_NULL);
      break;
    case IS_NOT_NULL:
      jj_consume_token(IS_NOT_NULL);
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void insertQuery() throws ParseException {
    jj_consume_token(INSERT_INTO);
    tableName();
    insertColumnsAndSource();
  }

  static final public void insertColumnsAndSource() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT_PAREN:
      columnNameList();
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    valueList();
  }

  static final public void valueList() throws ParseException {
    jj_consume_token(VALUES);
    jj_consume_token(LEFT_PAREN);
    value();
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_8;
      }
      jj_consume_token(COMMA);
      value();
    }
    jj_consume_token(RIGHT_PAREN);
  }

  static final public void value() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NULL:
      jj_consume_token(NULL);
      break;
    case INT_VALUE:
    case CHAR_STRING:
    case DATE_VALUE:
      comparableValue();
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void deleteQuery() throws ParseException {
    jj_consume_token(DELETE_FROM);
    tableName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      whereClause();
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static private boolean jj_3R_16() {
    if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
    return false;
  }

  static private boolean jj_3R_12() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(43)) {
    jj_scanpos = xsp;
    if (jj_scan_token(44)) {
    jj_scanpos = xsp;
    if (jj_scan_token(45)) {
    jj_scanpos = xsp;
    if (jj_scan_token(46)) {
    jj_scanpos = xsp;
    if (jj_scan_token(47)) {
    jj_scanpos = xsp;
    if (jj_scan_token(48)) return true;
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3_2() {
    if (jj_3R_10()) return true;
    return false;
  }

  static private boolean jj_3_3() {
    if (jj_3R_9()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  static private boolean jj_3R_9() {
    if (jj_scan_token(LEGAL_IDENTIFIER)) return true;
    return false;
  }

  static private boolean jj_3R_14() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) jj_scanpos = xsp;
    if (jj_3R_16()) return true;
    return false;
  }

  static private boolean jj_3R_13() {
    if (jj_3R_15()) return true;
    return false;
  }

  static private boolean jj_3R_11() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_13()) {
    jj_scanpos = xsp;
    if (jj_3R_14()) return true;
    }
    return false;
  }

  static private boolean jj_3_4() {
    if (jj_3R_9()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  static private boolean jj_3R_10() {
    if (jj_3R_11()) return true;
    if (jj_3R_12()) return true;
    if (jj_3R_11()) return true;
    return false;
  }

  static private boolean jj_3R_15() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(53)) return true;
    }
    }
    return false;
  }

  static private boolean jj_3_1() {
    if (jj_3R_9()) return true;
    if (jj_scan_token(PERIOD)) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public SimpleDBMSParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[28];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x2403c220,0x2403c200,0x2403c200,0x0,0x1800,0x400,0x1800,0x0,0x1c0,0x0,0x40000,0x80000,0x200000,0x0,0x80000,0x400000,0x800000,0x1000000,0x0,0x0,0x0,0x0,0x0,0xc0000000,0x0,0x0,0x10000000,0x200000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x8,0x100,0x0,0x0,0x8,0x0,0x8,0x100,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x300122,0x100,0x300120,0x1f800,0x300020,0x0,0x2,0x8,0x300020,0x0,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[4];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public SimpleDBMSParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SimpleDBMSParser(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SimpleDBMSParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public SimpleDBMSParser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SimpleDBMSParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public SimpleDBMSParser(SimpleDBMSParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(SimpleDBMSParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[56];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 28; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 56; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 4; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
